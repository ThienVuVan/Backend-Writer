* Java Backend Practice *

* JDBC *
	* JDBC (Java Database Connectivity) là một giao diện lập trình ứng dụng (API) trong Java cho phép các chương trình Java
	kết nối với cơ sở dữ liệu.
	* Nó cung cấp một cách tiêu chuẩn để truy cập và quản lý dữ liệu trong các hệ quản trị cơ sở dữ liệu (HĐCSDL) từ Java.
	* Một trong những ưu điểm quan trọng của JDBC là nó giúp trừu tượng hóa việc truy cập cơ sở dữ liệu đối với các nhà cung cấp HĐCSDL khác nhau.
	Tức là, cách truy cập cơ sở dữ liệu thông qua JDBC là giống nhau đối với tất cả các nhà cung cấp HĐCSDL,
	bất kể họ sử dụng hệ quản trị cơ sở dữ liệu nào như Oracle, MySQL, SQL Server, và nhiều hệ thống khác.
	Điều này cho phép chúng ta viết mã ứng dụng di động giữa các nhà cung cấp HĐCSDL khác nhau mà không cần thay đổi cú pháp
	hay cách thức truy cập cơ sở dữ liệu.
	* Khi chương trình Java gọi các phương thức JDBC để thực hiện các hoạt động như truy vấn dữ liệu, cập nhật dữ liệu,
	thực hiện giao tác, JVM (Java Virtual Machine) sử dụng một JDBC driver tương ứng để dịch các cuộc gọi JDBC tổng quát
	thành các cuộc gọi cụ thể cho nhà cung cấp HĐCSDL cụ thể. Mỗi nhà cung cấp HĐCSDL sẽ cung cấp một JDBC driver riêng để
	đảm bảo tích hợp ổn định và tương thích giữa ứng dụng Java và hệ quản trị cơ sở dữ liệu của họ.
	
	* Có 4 loại jdbc drivers: JDBC-ODBC Bridge Driver, Native Driver, Network Protocol Driver, and Thin Driver. Thin Driver
	được sử dụng phổ biến nhất. thin driver sẽ convert cuộc gọi trực tiếp tới database, nó có tốc độ nhanh và không cần phải
	cài đặt phần mềm bên client và server. và điểm yếu là driver phụ thuộc vào database, nghĩa là khi muốn kết nối với database
	nào thì cần đk riêng driver cho database vendor đó, dùng class.forname();
	
	* JDBC driver nó là một tập hợp các java class triển khai JDBD interfaces;
	
	* Để kết nói với db dùng jdbc, thì cần thực hiện 5 bước
		* 1. Regist driver class.
			Class.forName("com.mysql.jdbc.Driver"); 
		* 2. Create connection.
			* Phương thức getConnection() của lớp DriverManager được sử dụng để tạo connection với db.
			Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/ebookshop? allowPublicKeyRetrieval=true&useSSL=false&serverTimezone=UTC",
        	"myuser", "xxxx"); 
		* 3. Create statement.
			* createStatement() của Connection được sử dụng để khởi tạo một statement. đối tượng statement có nhiệm vụ
			thực hiện query với db.
			* hữu ích khi sử dụng với query tĩnh, bởi bì statement không chấp nhận tham số.
			stmt = conn.createStatement(); 
		* 4. Excute query.
			* executeQuery() của Statement được sử dụng để thực hiện query với db, nó sẽ trả về một ResultSet, là các bảng
			các record.
			ResultSet rs = stmt.executeQuery("SELECT * FROM EMP"); 
			* cách lấy các giá trị
			while(rs.next()){  
				System.out.println(rs.getInt(1) + " " + rs.getString(2));  
			} 
		* 5. Close connection.
			* close() của Connection sử dụng để đóng connection
			statement.close();
			con.close(); 
			* note: từ java 7, có thể sử sụng try-with-resources để tự động đóng connection.

	* DriverManager là class làm việc giữa user và driver, và có các phương thức để đk và tạo connection.
	* Connection là một phiên làm việc giữa app và db.
	* Mặc định, connection sẽ tự động commit sau khi thực hiện query sử dụng setAutoCommit(boolean status), mặc định là true,
	để hiểu phần này, các bạn sẽ đc học transaction ở phần sau để hiểu commit là gì.
	
	* JDBC Statement
		* Statement interface cung cấp các method để tạo và thực hiện các loại query.
			ResultSet executeQuery(String SQL) : Returns a ResultSet object
			int executeUpdate(String SQL) : Returns the numbers of rows affected
			
			Example 1: Execute a SELECT query via a Statement
			// Create and execute an SQL statement that returns some data.
			String SQL1 = "SELECT TOP 10 * FROM Person";
			Statement stmt=conn.createStatement();
			//ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE
			ResultSet rs = stmt.executeQuery(SQL);
			Example 2:	Execute an INSERT via a Statement
			// Create and execute an SQL statement that returns some data.
			String SQL2 = "INSERT INTO STOCK(STOCK_CODE, STOCK_NAME)
						   VALUES('11', 'STOCK1')";
			Statement stmt = conn.createStatement();
			int no_of_row = stmt.executeUpdate(SQL);
			
			* Retrieve data
			// Iterate through the data in the result set and display it.
			while (rs.next()) {
				System.out.println(rs.getInt(1) + "\t" + 
						rs.getString(2)+"\t"+rs.getInt(3));
			}
			
		* Thay vì phải đóng statement thù công, ta sử dụng try-with-resources để tự động đóng
			try (Statement statement = connection.createStatement()) {
				// use the statement in here.
			} catch (SQLException e) {
				  // TODO: handle exception
			}
		
	* JDBC ResultSet
		* là một interfaces đại diện có kết quả khi thực hiện query và có iterable.
		* chứa các records, mỗi record chưa các column và có số lượng column giống nhau mặc dù mỗi column có thể ko có giá trị.
		* Bạn có thể tạo một ResultSet bằng thực hiện Statement hoặc PreparedStatement.
		
	* JDBC PreparedStatement
		* mà một interfaces extend từ Statement.
		* được sử dụng để execute parameterized query.
		* tăng tốc độ bới vì với PreparedStatement, query chỉ được compile một lần.
		* dùng prepareStatement() method của Connection để tạo một đối tượng PreparedStatement.
		String SQL = "Update Employees SET age = ? WHERE id = ?";
		pstmt = conn.prepareStatement(SQL);
		* các phương thức để set parameter cho query trong prepareStatement;
			* public void setInt(int paramIndex, int value)
			* public void setString(int paramIndex, String value)
			* public void setFloat(int paramIndex, float value)
			* public int executeUpdate(): Executes the query. It is used for create, drop, insert, update, delete etc.
			* public ResultSet executeQuery(): Executes the select query. It returns an instance of ResultSet
		* ví dụ set parameter:
			pstmt.setInt(1,23); 
			pstmt.setString(2,"Roshan"); 
			pstmt.setString(3,"CEO"); 
			pstmt.executeUpdate();
		
	* Jdbc Callablestatement
		* được sử dụng để gọi stored procedures and functions. bạn nên học các khái niệm này trong sql.
		* prepareCall() method của Connection được sử dụng để khởi tạo một Callablestatement.
		CallableStatement stmt=con.prepareCall("{call myprocedure(?,?)}");
		
		
	* Transaction Management in JDBC
		* Transaction represents a single unit of work.
		* Transaction là một đơn vị công việc. nằm trong Connection.
		* đặc tính ACID nó mô tả tính chất của một transaction.
			ACID stands for Atomicity, Consistency, isolation and durability.
			Atomicity means either all successful or none.
			Consistency ensures bringing the database from one consistent state to another consistent state.
			Isolation ensures that transaction is isolated from other transaction.
			Durability means once a transaction has been committed, it will remain so, even in the event of errors, power loss etc.
		* void setAutoCommit(boolean status): set tự động commit.
		* void commit()
		* void rollback()
		
		* ví dụ: 
			// using PreparedStatement
			String query = “INSERT INTO Person “ + 
						   “VALUES (?, ?)”
			PreparedStatement statement = connect.prepareStatement(query);
			connect.setAutoCommit(false);
			statement.setString(1, “Titi”);
			statement.setInt(2, 25);
			statement.executeQuery();        // insert 1
			statement.setString(1, “Tata”);
			statement.setInt(2, 28);
			statement.executeQuery();        // Insert 2
			connect.commit();
			connect.setAutoCommit(true);

		* như đã biết, khi thực hiện query, khi transaction được commit thì dữ liệu mới được thay đổi trong db.
		* các bạn sẽ được học về đối tượng transaction trong hibernate.
		
	* Batch Processing in JDBC
		* một đối tượng statement chỉ thực hiện đươc một, không nó có thể thực hiện nhiều query cùng một lúc nhờ batch processing.
		* để thêm một query vào statement ta sử dụng:
			* void addBatch(String query)
		* và khi thực hiện query, ta không sử sụng excuteQuery() ta sử dụng:
			* int[] executeBatch(): It executes the batch of queries.
		* ví dụ: 
			Step 1:
			connect.setAutoCommit(false);
			Step 2: 
			Statement statement = connect.createStatement();
			statement.addBatch(<Insert query>);
			statement.addBatch(<Insert query>);
			statement.addBatch(<Update query>);
			statement.addBatch(<Delete query>);
			Step 3:
			int[] updateCounts = statement.executeBatch();
			connect.commit();
			statement.close();
			connect.setAutoCommit(true);
		* tại sao phải setAutoCommit(false), tại vì nếu ko set, Connection sẽ tự động commit.

* Summary
	Java JDBC Tutorial
	Working steps
	DriverManager class
	JDBC Statement
	JDBC ResultSet
	JDBC PreparedStatement (with Parameter)
	Jdbc Callablestatement 
	Transaction Management in JDBC
	Batch Processing in JDBC
	<------------------ Đó là tất cả những gì bạn cần biết về JDBC trong Java --------------------------------------------->


<------------------------------------- Hibernate Introduce ----------------------------------------->

* Trước tiên cần biết ORM là gì
	* Object Relation Mapping là một tư tưởng để chuyển dữ liệu từ relation db sang oop language.
	* JPA( java persistence api) là thư viện tiêu chuẩn hóa tư tưởng ORM, chứa các anotation và interfaces.
	* Hibernate là ORM FrameWork triển khai JPA. dùng để kết nối với db
	* Các fearture của hibernate:
		* Light-weight
		* Open-Source
		* Hight perfromace
		* Database Independent: no need to write sql, support many vendor.
		* Auto - Generation: auto gen table
		* ORM
		* Caching: first level and second level
		* Lazy Loading: load need dât
		* Scalability
		* HQL: interct with class, not table.
	* nói đi nói lại, thì Hibernate vẫn kết nối với db thông qua jdbc.
	* nếu chia tổng quan module, hibernate gồm config file và mapping file,
		* config file là nơi chứa các driver, connect url, username, passowrd, auto-gen table ..
	
	* Các core component của hibernate.
		* SessionFactory: là nơi chứa các component con phục vụ cho việc kết nối với db.
			SessionFactory sessionFactory = cfg.buildSessionFactory(); // cfg là file config, dạng xml
			
			* openSession(): method always opens a new session. // sesstion giống hệt Connection trong JDBC.
			* getCurrentSession(): method returns the session bound to the context. fater than open a new session. but need config in xml.
			* openStatelessSession(): method returns instance of StatelessSession
				StatelessSession in Hibernate does not implement first-level cache and it doesn’t interact with any second-level.
				nó giống hệt Connection của JDBC vì ko đc thừa hưởng benifit gì của hibernate.
		* Session 
			* cung cấp giao diện giữa app và db, dùng để kết nối với db.
			* các đối tượng pesistence được lưu và truy xuất thông qua session, chúng ta sẽ học về trạng thái của đối tượng sau.
			* cần được đóng khi ko dùng nữa, vì nó là unsafe thread.
			* là factory của Transaction, Query và Criteria.
			* nó có firt-level cache là default.
			* mở một session:
				Session session = sessionFactory.openSession();
		* Transaction
			* Tạo ra từ session, trong jdbc sử dụng transaction thông qua connection, thì ở đây ta có một đối tượng
			transaction riêng.
			
			* Cách khởi tạo:
				Transaction transaction = session.beginTransaction();     
				Serializable result = session.save(job);      
				transaction.commit();
	* Configuration
		* làm sao để class có thể liên quan đến table?
		* ta cần sử dụng config của hibernate.
		* giống như trong ứng dụng java có file properties, là file config của ứng dụng.
		* khuyến nghị sử dụng file config của hibernate là xml và tên file là cfg.xml
		* ví dụ:
			<?xml version='1.0' encoding='utf-8'?>
			<!DOCTYPE 	hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN“
					"http:// sourceforge.net/hibernate-configuration-3.0.dtd">
			<hibernate-configuration>
			<session-factory>
			<!-- Database connection settings -->
			<property name="connection.driver_class">com.microsoft.sqlserver.jdbc.SQLServerDriver</property>
			<property name="connection.url">jdbc:sqlserver://localhost:1433;databaseName=hrms</property>
			<property name="connection.username">sa</property>
			<property name="connection.password">12345678</property>

			<!-- JDBC connection pool (use the built-in) -->
			<property name="connection.pool_size">1</property>

			<!-- SQL dialect -->
			<property name="dialect">org. dialect.SQLServerDialect</property>

			<!-- Echo all executed SQL to stdout -->
			<property name="show_sql">true</property>

			<!-- Drop and re-create the database schema on startup -->
			<property name="hbm2ddl.auto">update</property>
			</session-factory>
			</hibernate-configuration>
	
	* Hibernate First Example
		* các bước để tạo một ứng dụng java sử dụng hibernate
			* Create the Java maven Project // sử dụng maven để quản lý thư viện
			* Add all required dependencies for hibernate // add dependencies vào file pom.xml để tự động load viện
			* Create the Persistent class // tạo class
			* Create the mapping file for Persistent class // thêm các anotation để đánh dấu map với table
			* Create the Configuration file // tạo file hibernate.cfg/xml trong resources.
			* Create the class that retrieves or stores the persistent object // tạo các class để mở session, và hứng data
			* Run the application // chạy thôi.
	* Summary
	Hibernate Overview
	Hibernate Features 
	Hibernate Architecture
	Configuration
	Hibernate First Example
	
	< --------------------------------- Hết rồi, nhớ ôn lại --------------------------->
	
< ------------------------------------ Hibernate Mapping ------------------------------------------------>
	* Basic Annotations
		* là các anotation trong JPA, quy định việc mapping giữa class và table.
	
	* Hibernate relationships
		* hiểu được Bi-directional và Uni-directional.
		* các anotation tự học, vì dài
	* Lazy loading and Eager loading
		* hiểu đơn giản
		* Lazy Loading: chỉ lấy data được chỉ định, chứ không lấy data có mối quan hệ với nó.
		* Eager loading: lấy data được chỉ định, đồng thời load luôn data có quan hệ.
< ----------------------------------- Hết -------------------------------------------->


<--------------------------------- Hibernate Query ------------------------------------->
	* trong bài này, cũng có vẻ dài nhưng nhớ được, chỉ có một đối tượng mới trong session là Query,
	đối tượng Query giống như statement của jdbc, để tực hiện một query, và có các phương thức để thực hiện và trả về
	
	* java cũng có ngôn ngữ truy vấn riêng là Java Persistence Query Language (JPQL), được phát triển từ HQL, là con của HQL
	nên một truy vấn JPQL luôn là một HQL hợp lệ, nhưng một truy vấn HQL chưa chắc là một truy vấn JPQL hợp lệ.
	
	* và trong spring data jpa, sử dụng JPQL. học sau.
	
	* hibernate cho phép sử dụng native query thông qua Session.createNativeQuery() method.
	* tạo một đối tượng query sử sử dụng native query
		Query<Employees> query = session.createNativeQuery(String query);
	* để thực hiện query, dùng phương thức list();
		* List<Object> list() method: returns the list of Object array
		* addEntity() and addJoin() methods to fetch the data from associated table using tables join
		* ví dụ: 
			Query<Jobs> query = session
				.createNativeQuery("SELECT * FROM dbo.Jobs")
				.addEntity(Jobs.class);
            
            return query.list();
			// có thể thấy, phải chỉ định class trả về thông qua addEntity(), khá phức tạp, và nếu ,muốn join phải dùng addJoin().
			Query query = session.createNativeQuery(
                    "SELECT j.*, e.* FROM dbo.Jobs j JOIN dbo.Employees e "
                    + "ON j.job_id = e.job_id")
                    	.addEntity("j", Jobs.class)
					.addJoin("e", "j.employees");
            
            List<Object[]> jobs = query.list();
		* có thể sử dụng parameter với đối tượng query và cho native query như sau
			Query query = session.createNativeQuery(
                    "SELECT * FROM dbo.Jobs j WHERE j.job_title LIKE :title "
                    + "AND j.min_salary <= :salary AND j.max_salary >= :salary")
                    .addEntity(Jobs.class);
            
            query.setParameter("title", "%" + title + "%");
            query.setParameter("salary", salary);
            
            return query.list();
			
		* @NamedNativeQuery dùng để định nghĩa trước một query và gán nó vào một name.
		* NamedNativeQueries chứa các NamedNativeQuery
			* ví dụ:
			Query<Employees> query = session
                    .createNamedQuery("FIND_EMP_BY_JOB"); // FIND_EMP_BY_JOB tên của query đó.
            
            query.setParameter("jobTitle", "%" + jobTile + "%");
            return query.list();
		
		* query.getSingleResult()
			* nếu bạn biết sql chỉ trả về một kết quả là số, thì sử dụng getSingleResult
			* ví dụ: 
				Query query = session.createNamedQuery("COUNT_EMP");
				query.setParameter("jobId", jobId);
				
				return (double) query.getSingleResult();
	
	* Hibernate Query Language
		* syntax giống với sql
		* sử dụng tên của bảng thay vì tên table, tên thuộc tính thay vì tên cột.
		* không phân biệt chữ hoa chữ thường với syntax
		* nhưng phân biệt chữ hoa và thường cho tên class và bảng.
		
		* ví dụ:
			String hql = "FROM Projects WHERE startDate >= :startDate";
			Query query = session.createQuery(hql);
			query.setParameter("startDate", startDate);
			List listResult = query.list(); // for select
			int rowsAffected = query.executeUpdate(); for insert, update, delete.
			
			// pageing
			Query query = session.createQuery("FROM Employees");
			query.setFirstResult(0);
			query.setMaxResults(10);
			return query.list();
			
			// thay vì sử dụng getSingleReulse của statement jdbc, ta dùng get(0);
			String hql = "SELECT COUNT(jobTitle) FROM Jobs";	
			Query query = session.createQuery(hql);
			List listResult = query.list();
			Number number = (Number) listResult.get(0);
			System.out.println(number.intValue());
			
	* @NameQueries: is used to define the multiple named queries.

	* @NameQuery: is used to define the single named query.
	// namequery của hibernate cũng tương tự namequery trong native sql, chỉ khác anotation
	
	* get() and load() là hai hàm thuộc về session, dùng để lấy data thông qua khóa chính, ko cần thực hiến query.
		* ví dụ:
			// Get Example
			User user = (User) session.get(User.class, new Integer(2));

			// Load Example
			User user = (User) session.load(User.class, new Integer(2));
		* get() method return null: If no row is available in the session cache or the database for the given identifier
			eager load the object, slower than load() because it return fully initialized , use when If you are not sure
			that object exist then use get() method 

		* load() method throws object not found exception, lazy load the object, slightly faster, use when If you are sure
			that object exist then use load() method 
	
	* Summary
		Queries Introduction
		 Native Query
		 Hibernate Query Language
		 Hibernate Named Query
		 Proxy Object
		 get() vs load() method
	
	< --------------------------- Hết ------------------------------->
	
< ------------------------ Hibetnate Object States/Lifecycle ----------------------------->
* bỏ qua hibernate criteria.

* có ba trạng thái của một object khi làm việc với ứng dụng java: Transient, Persistent và Detach.
	* Khi bạn khởi tạo một đối tượng, thì đối tượng đó đang ở trạng thái Transient, đơn giản thế thôi, ở trạng thái này,
		object không hề liên quan đến session, vậy nên Transient state không liên quan đến db. Transient object tồn tại
		trong heap, độc lập với hibernate.
		* ví dụ:
			Employee e=new Employee(); 
			e.setId(101);  
			e.setFirstName("Gaurav");  
			e.setLastName("Chawla");

	* Khi mà object được kết nối với session, thì nó được đưa vào trạng thái Persistent, object sẽ chuyển sang Persistent state
		khi chúng ta save() hoặc persist() object. mỗi object đại diện cho một row trong db.
		* ví dụ:
			session.save(e);  
			session.persist(e);  
			session.update(e);  
			session.saveOrUpdate(e);  
			session.lock(e);  
			session.merge(e); 
			
	* Khi chúng ta đóng session hoặc xóa bộ nhớ cache của session, object sẽ chuyển sang trạng thái detach, nghĩa là object
		không còn kết nối với session nữa, muốn đưa object trở lại trạng thái Persistent, thì ta cần đưa object đó vào một
		session mới, gọi là reattach bằng dùng các method sau của session: lock(), merge(), refresh(), update() or save()
		* ví dụ đưa object sang trạng thái detach:
			session.close();  
			session.clear();  
			session.detach(e);  
			session.evict(e);
* Các Hàm phổ biến để làm việc với object của session: persist(), save(), merge(), update(), saveOrUpdate().
	* persist()
		* dùng để thêm một object transient vào persistent context
		* câu lệnh insert chỉ sinh ra khi gọi transaction.commit() hoặc session.close()
		* nếu object ở trạng thái persistent thì sẽ ko có gì thay đổi với đt đó trong context.
		* nếu truyền vào là detach object, thì sẽ ném ra lỗi khi gọi method này hoặc khi commit hoặc flush.
		* Bản đặc tả không nói đến id của đối tượng sẽ được sinh ra ngay lúc gọi hàm persist() ,
			dù cho ta chọn cách sinh ID như nào đi nữa. Bản đặc tả cũng cho phép các implementation của hàm persist()
			sinh ra câu lệnh SQL để generate ID cho đối tượng vào lúc commit hoặc flush session, và thế nghĩa là ID 
			của đối tượng không hề được đảm bảo sẽ được sinh ra sau khi gọi hàm này, cho nên ta có thể gặp NULL nếu get
			cái ID ra sau khi gọi persist().
		* ví dụ:
			Person person = new Person();
			person.setName("John");
			session.persist(person);

	* save()
		* Hàm này là hàm gốc của hibernate, nó không tuân thủ đặc tả của JPA cho lắm.
		* tức là với một số kiểu dữ liệu, hàm này không cần commit transaction, nó tự động commit, điều này
			dẫn đến một số lỗi ko đáng có và kho kiểm soát object.
		* nên tốt nhất hãy dùng persist().
		* khi save() một detach object, nó sẽ tạo ra một đối tượng mới trong context mới một id mới, điều này là không
			mong muốn bởi vì sẽ làm duplicate row trong db khi commit hoặc flush. đó, điều này là bất lợi thứ hai.
		* ví dụ:
			Person person = new Person();
			person.setName("John");
			Long id = (Long) session.save(person);
			
	* merge()
		* Mục đích chính của hàm merge là để cập nhật giá trị cho persistent object trong context từ detach object.
		* khi truyền vào là một detach object, nó sẽ copy các giá trị bên trong và gán vào persistent object.
		* khi truyền vào là một transient object, nó sẽ tạo ra một persistent object mới trong context.
		* nếu truyền vào là persistent, thì sẽ ko có tác động gì.
		* ví dụ:
			Person person = new Person(); 
			person.setName("John"); 
			session.save(person);

			session.evict(person);
			person.setName("Mary");

			Person mergedPerson = (Person) session.merge(person);
			
	* update()
		* giống như save(), là một hàm gốc của hibernate.
		* mục đích chính là để đưa một detach object lại thành một persistent object. nó cũng copy giá trị như merge.
		* nhưng khi truyền vào một transient, nó sẽ ném ra lỗi ngay. bất tiện đko.
		* ví dụ:
			Person person = new Person();
			person.setName("John");
			session.save(person);
			session.evict(person);
			 
			person.setName("Mary");
			session.update(person);

	* saveOrUpdate()
		* method này chỉ xuất hiện trong hibernate API, và nó như là phiên bản cải tiến của update()
		* nó khác update duy nhất là khi truyển một transient, nó tạo một persistent object mới chứ ko ném ra lỗi
			hay đúng không.
		* ví dụ:
			Person person = new Person();
			person.setName("John");
			session.saveOrUpdate(person);

	* Tóm lại, khi làm việc với hibernate, bạn chỉ nên dùng persist, merge và saveOrUpdate.

< -------------------------------- Hết --------------------------------------->


< -------------------------------- Hibernate Validator - Java Bean Validation ---------------------------------->
	Validation annotations
	Validating Ranges
	Validating Strings
	URL and HTML Validation
	Hibernate validation @Pattern
	
	* Hibernate Validator hay còn gọi là java bean validation, vì hibernate là một java framework, nên Hibernate Validator
	như là một java bean validation.
	* JSR 380 (Java Specification Request) là đặc tả cho java bean validation. là một phần của jakarta ee và java se.
	* cần thêm thư viện để sử dụng.
	
	* để hiểu về các anotaion, đọc slide, vì dài.
	* phần này không có gì phức tạp cần giải thích, tự đọc slide.
 -------------------------- Hết --------------------------------
 
 -------------------------- Hibernate Caching ---------------------
 * phần này khá quan trọng, cần nắm bắt tốt để biết luồng chạy của data.
 
 * Caching in Hibernate
	* hibernate cache giúp tăng hiệu xuất chương trình, giảm số lượng query.
	* hibernate cung cấp 3 loại cache của một session:
		First Level Cache
		Second Level Cache
		Query Cache
	
	* First Level Cache
		* First Level Cache được kết nối với session, được bật default và không có cách nào để tắt đi cả.
		* tất cả các object trong cache của session sẽ không được nhìn thấy bởi session khác, và khi đóng session,
		tất cả object trong cache cũng mất.
		
		* hibernate cung cấp một số method để chúng ta có thể làm việc với các object trong first level cache.
			evict() remove a single object from the hibernate first level cache.
			clear() clear the cache: delete all the objects from the cache.
			contains() check if an object is present in the hibernate cache or not.
			* xem ví dụ trong slide.
	
	* Hibernate First Level Cache được kết hợp với đối tượng Session (phiên làm việc).
	First Level Cache được mặc định sử dụng trong Hibernate và bạn chẳng cần phải làm gì để bật nó lên cũng như không
	có cách nào để tắt nó đi cả. Tuy nhiên, Hibernate cung cấp các phuơng thức mà thông qua nó, chúng ta có thể xóa bỏ
	các đối tượng được lựa chọn từ bộ nhớ cache hay giải phóng bộ nhớ cache 1 cách hoàn toàn. Bất cứ đối tượng đuợc cách
	nào trong 1 session (phiên làm việc) sẽ không bị ảnh hưởng bởi các session khác và khi session đó bị đóng lại, tất cả
	các đối tượng được cache đó cũng sẽ bị mất.

CÁC ĐẶC ĐIỂM QUAN TRỌNG CẦN CHÚ Ý
* First Level Cache được kết hợp với đối tượng "session" và các đối tượng session khác trong ứng dụng không thể
 "nhìn thấy" hay làm ảnh hưởng
* Phạm vi của cách đối tượng cache này là session (phiên). Khi một session bị đóng lại, các đối tượng cache thuộc
 session đó sẽ vĩnh viễn bị mất đi.
* First Level Cache là mặc định trong Hibernate và không có cách nào để disable nó cả.
* Khi chúng ta truy vấn 1 thực thể (abc) lần đầu tiên, nó sẽ được lấy về từ database và được lữu trữ trong bộ nhớ
 của first-level cache - cái mà được liên kết với đối tượng hibernate session
* Nếu chúng ta truy vấn lại cùng 1 đối tượng (abc) với cùng session, nó sẽ được load từ trong cache thay vì việc thực
 thi lại câu truy vấn sql
* Thực thể (abc) được load có thể bị xóa khỏi session, khỏi bộ nhớ first level cache bằng việc sử dụng phuơng thức
 evict(entity). Như vậy, vào lần tiếp theo ta truy vấn thực thể đó, nó sẽ được lấy từ database (thay vì bộ nhớ cache).
* Toàn bộ bộ nhớ cache của session có thể bị làm trống với việc sử dụng phuơng thức clear(). Điều này có nghĩa là các
 thực thể được lưu trữ trong bộ nhớ cache cũng sẽ bị xóa bỏ.
 

	* Second Level Cache
		* second level cache giống như first level cache, chỉ khác một số điều sau
			* second level cache không được tự động bật cho các object, phải cấu hình để cho phép các object đc lưu trong 
			second level cache.
			* slc không có sẵn trong hibernate, hibernate sử dụng các provider bên ngoài dùng làm slc, như EHCache.
			* cần thêm dependencies vào pom, và config trong file config của hibernate, và config trong mỗi class.
			* khi đối tượng được config, khi truy xuất đối tượng ra, object sẽ đc lưu trong flc, và đồng thời cũng đc lưu
			trong slc.
			* khi đóng session, đối tượng vẫn tồn tại trong slc mặc dù flc đã mất.
			* lý do bởi vì flc là session scope, còn slc là sessionFactory scope, nghĩa là chia sẻ cache cho mọi session, và
			chỉ có một slc trong chương trình.
			* và khi truy xuất đối tượng đó, nó sẽ tìm trong flc, nếu không có nó sẽ tìm trong slc, nếu không có nữa thì
			mới thực hiện query. rất đặc biệt phải không.
		* Tham khảo code trong slide nhé.
	
	* Query cache: phần này tham khảo trong slide, vì không quan trọng lắm.
	
< ------------------------------------ Entity Manager ------------------------------------->

* Trong JPA, nó cũng có Module để làm việc với db, và nó gần như tương sự với sessionFatory
	đó là EntityManagerFactory.
	* để khởi tạo sessionFactory, ta cần file config của hibernate.
	* để khoi tạo  EntityManagerFactory ta cũng cần file config có tên Pesistence.xml;
	* nhưng trong spring boot, spring sẽ tự động load và khởi tạo EntityManager là bean trong context, nên chỉ cần lấy
	ra dùng bằng anotation @Autowired hoặc @PersistenceContext.
	* thường thì nếu gặp một query khó mà spring data jpa không làm được, thì ta dùng entity manager.

Transient, Persistent, và Detached State:

* Trong JPA, cũng có ba trạng thái chính của đối tượng: Transient, Persistent và Detached.
	Trạng thái Transient: Đối tượng ở trạng thái này không liên quan đến EntityManager và không có kết nối với cơ sở dữ liệu.
	Đối tượng tồn tại trong bộ nhớ heap và độc lập với JPA.
	Trạng thái Persistent: Đối tượng được đưa vào trạng thái này bằng cách sử dụng persist() hoặc merge() và đại diện cho một
	hàng trong cơ sở dữ liệu. Các thay đổi trên đối tượng sẽ được theo dõi và có thể được tự động cập nhật vào cơ sở dữ liệu
	khi gọi commit() hoặc flush().
	Trạng thái Detached: Khi EntityManager đóng hoặc xóa bộ nhớ cache, đối tượng chuyển sang trạng thái Detached,
	nghĩa là không còn liên quan đến EntityManager. Để đưa đối tượng trở lại trạng thái Persistent, bạn cần thực hiện
	reattach bằng cách sử dụng các phương thức như merge(), refresh(), update(), hoặc persist() trên một EntityManager mới.
	Các Phương Thức Phổ Biến khi làm việc với Đối Tượng của EntityManager:

* persist():
	Dùng để thêm một đối tượng Transient vào trạng thái Persistent trong EntityManager.
	Câu lệnh INSERT sẽ được sinh ra sau khi gọi commit() hoặc flush().
	Nếu truyền một đối tượng Detached hoặc Persistent, nó sẽ ném ra lỗi khi gọi phương thức này hoặc khi commit() hoặc flush().

* merge():
	Mục đích chính của merge() là cập nhật giá trị của một đối tượng Persistent trong EntityManager từ một đối tượng Detached.
	Khi truyền một đối tượng Detached, merge() sẽ sao chép các giá trị từ đối tượng Detached vào đối tượng Persistent.
	Khi truyền một đối tượng Transient, merge() tạo một đối tượng Persistent mới trong EntityManager.
	Nếu truyền một đối tượng Persistent, không có tác động gì.
	
* update():
	Tương tự như save(), update() là một phương thức gốc của Hibernate và không tuân thủ đặc tả JPA một cách chặt chẽ.
	Mục đích chính của nó là đưa một đối tượng Detached thành một đối tượng Persistent.
	Không chấp nhận đối tượng Transient, và ném ra lỗi nếu truyền vào đối tượng Transient.
	
* saveOrUpdate():
	saveOrUpdate() chỉ tồn tại trong Hibernate API và có một phiên bản cải tiến của update().
	Nó tương tự update(), nhưng khi truyền vào đối tượng Transient, nó tạo một đối tượng Persistent mới trong EntityManager,
	 không ném ra lỗi.
* entityManager.detach(entity): ngắt kết nối đối tượng với entityManager, tức là loại ra khỏi persistence context.
* entityManager.refresh(entity): làm mới đối tượng trong pesistence context bằng cách lấy lại từ db.
* entityManager không có cách nào để clear pesistence context, chỉ khi tạo một entityManager khác.


Các phương thức này tương tự với Hibernate nhưng sử dụng EntityManager trong JPA.
 Khi làm việc với JPA, bạn nên ưu tiên sử dụng persist(), merge(), và saveOrUpdate()
 theo đúng đặc tả của JPA để đảm bảo tính di động và sử dụng tiêu chuẩn hơn.
 
* Học về entity manager *
 * Mặc định khi khởi chạy app trong spring boot, spring data jpa sẽ khởi tạo entitymanager trong context, có thể lấy
	ra dùng luôn.
EntityManager trong Java Persistence API (JPA) và Session trong Hibernate có nhiều sự khác biệt và tương tự trong việc
 quản lý đối tượng thực thể và tương tác với cơ sở dữ liệu. Dưới đây là một số khác biệt chính giữa chúng:

* Trạng thái Entity:
	Trong EntityManager, đối tượng thực thể có 3 trạng thái chính: transient, persistent và detached.
	Trong Session của Hibernate, có 4 trạng thái: transient, persistent, detached và removed (đối với đối tượng được xóa).
* Cơ Chế Caching:
	EntityManager sử dụng first-level cache, được gọi là persistence context, để lưu trữ các đối tượng thực thể trong bộ nhớ tạm thời.
	Session trong Hibernate cũng sử dụng first-level cache, được gọi là session cache, để lưu trữ các đối tượng thực thể.
* Truy Vấn SQL:
	EntityManager sử dụng truy vấn JPQL (Java Persistence Query Language) để truy vấn đối tượng thực thể.
		và cũng hỗ trợ native query. 
	Session của Hibernate hỗ trợ truy vấn HQL (Hibernate Query Language) cùng với truy vấn SQL native.
* Hàm Chấp Nhận Dữ Liệu Trạng Thái:
	EntityManager cung cấp các phương thức persist(), merge(), và remove() để quản lý dữ liệu thực thể.
	Session trong Hibernate cung cấp các phương thức save(), update(), delete(), và saveOrUpdate() để quản lý dữ liệu thực thể.
* Lỗi Gây Ra Bởi Hàm Trong Trạng Thái Không Đúng:
	Trong EntityManager, gọi remove() trên một đối tượng transient hoặc detached sẽ gây ra ngoại lệ.
	Trong Session của Hibernate, gọi delete() trên một đối tượng transient hoặc detached cũng sẽ gây ra ngoại lệ.
* Chuyển Trạng Thái Của Entity:
	Để chuyển một đối tượng từ transient sang persistent trong EntityManager, bạn sử dụng persist() hoặc merge().
	Để chuyển một đối tượng từ detached sang persistent trong EntityManager, bạn sử dụng merge().
	Trong Session của Hibernate, bạn sử dụng save() hoặc update() để chuyển từ transient sang persistent,
	 và merge() để chuyển từ detached sang persistent.
* Cách Làm Việc Với Truy Vấn SQL Native:
	EntityManager sử dụng createNativeQuery() để thực hiện truy vấn SQL native.
	Session của Hibernate cung cấp createSQLQuery() cho truy vấn SQL native và createQuery() cho truy vấn HQL.
* Đối Tượng Kết Quả Trả Về:
	Trong EntityManager, kết quả của truy vấn thường là đối tượng thực thể hoặc danh sách đối tượng thực thể.
	Trong Session của Hibernate, kết quả truy vấn có thể là danh sách các đối tượng thực thể, danh sách các đối tượng tùy chỉnh,
	danh sách mảng đối tượng, và nhiều loại dữ liệu khác.
* EntityManager của JPA không hỗ trợ second - level - cache, nhưng nếu sử dụng EntityManager của hibernate thì có.
 
 

--------------------------------- SPRING FRAMEWORK - Introducetion ----------------------------- 
The Spring Framework is a Java platform that provides comprehensive infrastructure support for developing Java applications
* có nhiều module như dataaccess, Web, core container, AOP, Aspect ...

* Spring Ioc (Inversion of Control)
	* đảo ngược sự kiểm soát, tức là với code thông thường, các bạn phải khởi tạo một đối tượng để dùng, nhưng với cơ chế IOC,
	bạn chỉ cần cấu hình, mọi thứ còn lại để spring lo.
	* với IOC, spring sẽ đọc file cấu hình vào tự động khởi tạo các đối tượng trong ApplicationContext, muốn dùng
	một đối tượng, bạn chỉ cần lấy đối tượng ApplicationContext thông qua API ClassPathXmlApplicationContext(). và từ context
	lấy ra bean đã đc khởi tạo để sử dụng.
	* các bước để thực hiện IOC:
		Load jar files // đây là load thư viện cần thiết // xem slide
		Bean Class // tạo class bình thường, bean class là class để tạo ra bean.
		XML file // file cấu hình để spring đọc để khởi tạo bean.
		Demo Class // demo truy suất
		Run
	* ví dụ về demo class:
		ApplicationContext context = new ClassPathXmlApplicationContext("employeeBean.xml");
		// employeeBean.xml là file config.
		Employee emp1 = (Employee) context.getBean("emp1");
		Employee emp2= (Employee) context.getBean("emp2");

		System.out.println("Employee details: " + emp1);
		System.out.println("Employee details: " + emp2);
	* trong spring, có hai kiểu container hay là context.
		* BeanFactory: là container đơn giản nhất có hỗ trợ dependency Ịnection
		* ApplicationContext: xây dựng dựa trên BeanFactory, hỗ trợ nhiều tính năng hơn. (recommend).
	* các đối tượng được khởi tạo trong context được gọi là bean, bạn đã hiểu chưa.
	
* Spring bean
	* Beans are the objects that form the backbone of our application and are managed by the Spring IoC container.
	* Spring IoC container instantiates, assembles, and manages the bean object.
	* The configuration metadata that are supplied to the container are used create Beans object.
	// ba khái niệm về bean.
	
	* Bean có khá nhiều thuộc tính quan trọng, nhưng chúng ta nhắc đến vài cái thiets yếu nhất:
		* Lazy - initailize: nói cho spring IOC biết rằng chỉ khởi tạo một đối tượng khi nó được yêu cầu lấy ra dùng,
			chứ không phải khởi tạo khi chạy chương trình, để tiết kiệm bộ nhớ.
		* Scope
			* singleton: là chỉ một bean của một class đó được tạo trong context, nhiều lần truy xuất bean đó, thì chỉ có
			một bean trong context được trả ra, tức là nhiều biến trỏ đến một bean, chứ không phải mỗi lần truy xuất làm
			tạo ra một bean mới.
			* prototype: mỗi lần truy xuất đều tạo ra một bean mới, nên mỗi biến trỏ bến một bean khác nhau. tùy vào mục
			đích sử dụng mà chúng ta chọn scope thích hợp.

* Spring DI (tiêm phụ thuộc)
	* nó được thiết kế để giúp quản lý chương trình tốt hơn, và giúp mối liên hệ trong chương trình lỏng lẻo hơn(Loosely couple)
	giúp các thành phần ít liên quan đến nhau, ít xảy ra lỗi hơn.
	* trong chương này, chúng ta mới chỉ học tiêm phụ thuộc bằng trong file config xml, cta sẽ học tiêm bằng anotation,
	và config tạo bean bằng anotation sau.
	* DI cung cấp hai cách để tiêm phụ thuộc
		* Constructer.
		* Setter.

------------------------------- Spring MVC -------------------------------------
* Mô hình mvc là một kiến trúc phần mềm sử dụng để tổ chức ứng dụng thành 3 phần chính
	* Model: đại diện cho dữ liệu và logic để sử lý dữ liệu. phần quản lý và truy suất dữ liệu.
	* View: đại diện cho giao diện người dùng, view hiển thị thông tin từ model và thu thập thông tin.
	* Controller: là cầu nối giữa model và view, nơi nhận yêu cầu thông qua view, xử lý nó bằng cách tương tác với model.
		sau đó cập nhật view với dữ liệu mới.
* Nói luôn về mô hình 3 lớp: cũng là một kiến trúc để phát triển ứng dụng để dễ dang quản lý, phân thành 3 tầng
	Controller, Service, DataAccess.
	* Controller: đại diện cho lớp điều khiển, và làm việc với lớp service để thực hiện logic kinh doanh.
		Trong MVC thì trả về View.
		Trong RestFul thì trả về http Response (ResponseEntity).
	* Service layer: chứa logic của ứng dụng, nó thực hiện các chức năng cụ thể của ứng dụng, gửi và truy cập lớp dataaccess
		cung cấp các dịch vụ cho controller.
	* DataAccess layer: lớp này có nhiệm vụ tương tác với database hoặc bất kì nguồn dữ liệu nào khác, chịu trách nhiệm truyền
		dứ liệu cho service layer, thường sử dụng jdbc, hibernate, spring data jpa để kết nối với db.
	* mô hình 3 lớp giúp tách biệt ứng dụng thành các cấu trúc rõ ràng, dễ bảo trì, mở rộng và kiểm thử.

* spring web mvc là một phần của spring framework dùng để tạo web application, hỗ trợ IOC, DI, sử dụng Dispatcheservlet để
bắt request. default handler dựa trên @Controller và @RequestMapping anotation.

* Trong mô mình web mvc sử dụng jsp/servlet cũ, thì servlet như là controller, jsp là view, model là các java bean, và servlet
sẽ đứng ra nhận request.
* Trong mô hình spring web mvc, cấu trúc có khác đi, có thể sử dụng nhiều công nghệ, @Controller và @RequestMapping đánh
dấu class đại diện cho phần controller, View có thể sử dụng jsp, themleaf..., model có thể chia làm nhiều layer. về phần
cấu trúc thì xem trong  slide.

* làm thế nào để xây ứng dụng mvc với xml.
	* Bàn cần cấu hình hai file: web.xml và spring-servlet.xml
		* web.xml là cấu hình dispatcherservlet, xem cấu trúc sẽ hiểu.
		* spring-servlet.xml là cấu hình các bean cần thiết, scan cac anotaion để khởi tạo bean.
	
	* Tạo class controller: cấu hình class với anotaion @Controller: đơn giản để spring ioc quét và hiểu đây là controller,
		và các api đánh dấu với @RequestMapping và url để Dispatcheservlet biết nơi request cần đến.
	
	* Cấu hình ViewResoler trong spring-web.xml để spring biết lối tìm view.
	
	* để biết chi tiết nhất, hãy thực hành.
	
* Spring @Autowired
	* Như ở bài trước ta đã học dependency injection nhưng bằng xml, khá là bất tiện, trong phần này, ta học injection
	bằng anotaion @Autowired, thuận tiện hơn rất nhiều.
	* spring có cơ chế spring bean auto wiring, một lưu ý đặc biệt, @Autowired chỉ có thể dùng trong bean, nghĩa là bean
	auto wire vào bean, chứ không để auto wire class ko phải là bean, trong phần xml chúng ta cũng đã hiểu rõ điều này.
	* ví dụ: xem slide vì ko copy đc.
	* như bạn thấy, @component đánh dấu class này sẽ đc tạo thành bean khi app chạy, bạn sẽ đc học sâu hơn về component ở
	phần sau, và hãy đảm bảo rằng bạn cấu hình đúng để spring có thể quét được lớp này.
	* như bạn đã thấy đoạn code sau:
		@Configuration
		@ComponentScan(basePackages = { "fa.training.controller" })
		public class WebMvcConfig {}
		// ta có thể cấu hình bằng class thay vì xml, bạn có thể học rõ hơn về bài sau.
	* trong ví dụ bạn xem, bạn thấy @Autowired đặt ở field, nghĩa là field injejection, điều này chương trình vẫn chạy đúng
	nhưng tôi không khuyến khích field injection, vì nó có thể gây ra vài lỗi nullpointerexception khi bean không khởi tạo đc.
	hãy dùng contructor injection.
	
	* các bược cơ bản tạo web mvc
	The steps are as follows:
	Create the request /respone pages
	Create the bean/controller/service/dao class
	Provide the entry of controller in the web.xml file
	Define the bean in the xml file
	Start server and deploy the project
	// hãy xem code mẫu trong slide để hiểu rõ hơn.

* Nói một chút về servlet:
	* servlet như tầng controller trong mvcc, đứng ra để xử lý các request và trả về view hoặc respone http. đó, dễ hiểu.
	
--------------------------------------------------- Hết ----------------------------------------------


-------------------------------------------- HIBERNATE AND SPRING MVC INTEGRATION ---------------------------
* từ phần này mình nghĩ các bạn đã có kiến thức để tự đọc hiểu các phần sau rồi.
* Lưu ý rằng, khi làm việc với các đối tượng để kết nói với db như session hay entitymanager, với các câu lệnh insert, update
	delete thì phải bắt đầu transaction và đóng, đối với select thì không cần.

* để biết sử dụng messager box error cho nhiều cái trùng nhau, thì xem slide 38 spring mvc component.
* Tổng quan bài MVC Component.
	* @RequestParam: dùng để bind parameter được gửi trong url
		* các tham số cần chú ý: value, require, bắt kiểu optional, bắt vào một list.
	* @ModelAtribute: dùng để bind dữ liệu trong body vào biến, có thể bind nhiều kiểu ảnh, video, file ...
	* @RequestBody: dùng để bind dữ liệu trong body vào biến, không bind được dữ liệu ảnh, video, file ...

* Tông quan bài Validation và Intercepter
	* cần biết: @ControllerAdvice, @ExceptionHandler, @ResponseSatus,
	* @ControllerAdvice: là bean class, bắt tất cả các exception được ném ra từ controller.
	* @ExceptionHandler: định nghĩa phương thức để xử lý exception cụ thể.
	* @ResponseSatus: định nghĩa status http của exception trả về, nhưng trong thực tế, đều trả về ResponseBody, có set
	status trong đó hết, nên không cần dùng.


-------------------------------------------- Spring Boot ----------------------------------------------
* trước khi vào, ôn lại chút spring framework là gì?
	* spring framework không hẳn là một framework, nó là một flatform của java dành cho việc phát triển application,
	nó cung cấp rất nhiều module để làm việc, dataaccess, web, core container, aop ...
	* có hai khái niệm quan trọng khi làm việc với spring là IOC và DI nằm trong module core container.
	* nó vẫn còn khá cồng kềnh trong việc phát triển application, chúng ta có thể thấy, việc config các công nghệ sử dụng
		và bean cần thiết vẫn còn khá phức tạp, cta phải config bằng xml, spring ko bt tự động config cho cta, như config
		hibernate, dispatcherservlet, spring-servlet.xml, ... làm việc với xml khá bất tiền vì cú pháp ko thân thiện.
	* chương trình nào mà chả dùng dispatcherservlet đko, tại sao spring framework không config luôn cho cta?
	* khi muốn chạy chương trình, mà muốn nhận đc yêu cầu http, ta lại phải cài thêm các web server vào ide, và chọn webserver
		khi khởi chạy chương trình, bất tiện đko
	* và spring boot ra đời để giải quyết những vấn đề này.
	
	
* Spring boot là một spring module cung cấp RAD fearture cho spring framework, Rapid Application Development.
* Spring boot là mã nguồn mở, dùng cho việc phát triển micro service.
* Spring boot là một project được built trên spring framework, nó giúp dễ dàng và tăng hiệu suất trong việc setup, config
	và run app.
* Spring boot đưa ra 3 lý do sau cho developer:
	* Easy to understand and develop spring applications
	* Increases productivity
	* Reduces the development time
* Spring boot là sự kết hợp của spring framework, cộng với web server (tomcat, jetty ...) + @Configuration = Spring boot.


* Spring Boot Annotations *
	* @SpringBootApplication: nằm ở hàm main của chương trình, nó là gộp của anotation sau:
		* @EnableAutoConfiguration: enable auto-configuration mechanism.
		* @ComponentScan: enable @Component scan.
		* @SpringBootConfiguration: register extra beans in the context
	* khi chạy hàm main, spring sẽ tự động scan các component trong packagecon, bootstrap các file properties hay yml
		và load vào spring context.
	* nên nhớ rằng, mọi component muốn được load thì phải nằm trong package con của package chứ hàm main.
	* với spring boot, mói thứ cấu hình bạn chỉ cần đặt trong file properties hoặc yml.
	* spring boot có nhiều dependencies hữu dụng, xem slide spring boot basic.

* Nói một chút cho các bạn phân biệt về mô hình mvc và rest api trong spring boot chạy như thế nào?
	* như bạn đã biết, dispatcherservlet sẽ nhận mọi request, tham khảo handlerMapping và đưa vào Controller
	* nếu trong mô hình mvc, dữ liệu sẽ được bind vào model và trả về view, dispatcherservlet lại dựa vào viewResolver
		để tìm view vật lý và bind model vào đó, và trả về một trang html mới.
	* nhưng với rest api, controller lại trả về một http response, chứ không phải là một view, và dữ liệu trả về thường
		là json. bên frontend có trách nhiệm nhận và xử lý data.
		* spring-boot cũng được xây dựng trên jackson-bind, jackson-bind là thư viện dùng để bind các java object thành 
			json và ngược lại.
	* đó là sự khác biệt, chỉ là cắt gọn đi đoạn sau.
	* khi spring boot chạy, các bạn sẽ thấy dispatcherservlet đc tự động khởi động.

* REST (REpresenttational State Transfer) lần đầu tiên được giới thiệu vào năm 2000 trong luận văn tiến sĩ của Roy Thomas
	 Fielding (đồng sáng lập giao thức HTTP). Trong luận văn ông giới thiệu khá chi tiết về các ràng buộc, quy ước cũng như
	 cách thức thực hiện với hệ thống để có được một hệ thống REST. Hiểu một cách đơn giản, REST là một hệ thống các ràng buộc
	 (constraints), chỉ cần đảm bảo những điều đó hệ thống của bạn có thể được gọi là RESTfull.

* RESTful (REpresentational State Transfer) là một kiểu Web Service được viết dựa trên kiến trúc REST.
	Các đặc điểm của RESTful web service:
	Sử dụng các phương thức HTTP/HTTPs
	Phi trạng thái (stateless) (không lưu trữ thông tin của client)
	Hiển thị cấu trúc thư mục như các Urls
	Truyền tải dữ liệu với định dạng phong phú: html, json, text, xml… (thường sử dụng nhiều với json)

* Dữ liệu và các tính năng được coi như tài nguyên và được truy suất thông qua các URI (Uniform Resource Identifier)
	REST sử dụng 4 phương thức chính của HTTP là POST, GET, PUT và DELETE để thực hiện các hành động CRUD đối với các tài nguyên
	Restfull API là một tiêu chuẩn dùng trong việc thiết kế các thiết kế API. Các web service thường được áp dụng các cấu trúc
	REST vào để xây dựng
	Các cấu trúc cơ bản của cấu trúc REST:
	Sử dụng các phương thức HTTP một cách rõ ràng
	Phi trạng thái
	Hiển thị cấu trúc thư mục như các URLs
	Truyền tải JavaScript Object Notation(JSON), XML hoặc cả hai

	
--------------------------------------------- SPRING DATA JPA -----------------------------------------------------
* bây giờ chúng ta sẽ học một thư viện mới của spring framwork, kết nối với cơ sở dữ liệu cực gi dễ dàng.

* Spring data jpa là một module của spring framework, mục tiêu của module này là để giảm số lượng code khi làm việc với
	db, hỗ trợ hibernate.
* sdj không phải là một jpa provider, nó là một thư viện, framework thêm vào lớp abtraction xây dựng bên trên jpa provider,
	cụ thể ở đây là hibernate.
* nếu sử dụng sdj, tầng repository của app sẽ chia làm 3 tầng chính: spring data jpa, spring data common, jpa provider.
	* tầng spring data jpa hỗ trợ tạo jpa repository bằng việc extend các interfaces
	* tầng spring data common gồm các cấu trúc repo, các bạn sẽ học phần sau.
	* tầng jpa provider là tầng triển khai jpa, cụ thể hibernate.

* Một lưu ý nhỏ khi các bạn xem thư viện của spring data jpa, các bạn sẽ thấy interface kế thừa interface, đó là interface
	inheritance, khi bạn muốn chia tách các interface cha con. interface con có thể có giao diện của lớp cha. interface
	không thể implement interface nhé.
	* abstract class cũng như thế, nếu bạn muốn kế thừa lớp cha mà không muốn triển khai các phương thức abstract của lớp cha
	thì lớp con bạn kế thừa cũng phải là một lớp abstract.

* Spring Data Commons: bao gồm các interface sau đây, xắp xếp từ trên xuống dưới, trên là interface cha, dưới là interface con
	* Repository<T, ID extends Serializable> interface
	* CrudRepository<T, ID extends Serializable> interface
	* PagingAndSortingRepository<T, ID extends Serializable> interface // có hai phương thức findall, nhận vào pageable và sort
	* JpaRepository<T,ID> // con dưới cùng, có tất cả phương thức của interface bên trên, sử dụng cái này nhiều nhất.
	* để biết thêm ở trong đó có những cái gì, xem slide.
	
	* ngoài ra, còn có hai interface nữa nhưng đứng độc lập:
		* QueryDslPredicateExecutor interface: chủ yếu nhận tham số vào là pridicate.
		* JpaSpecificationExecutor interface: chủ yếu nhận vào là một specification.
* Pagination và Sorting
	Pageable firstPageWithTwoElements = PageRequest.of(0, 2);
	Pageable sortedByPriceDesc = PageRequest.of(0, 3, Sort.by("price").descending());
	// Pageable là một interface, đối tượng pageable được tạo thông qua pagerequest, các bạn có thể tham khảo thêm để biết
	nhiều hơn về phần này.
	// ví dụ: Page<Product> findByPriceLessThan(double price, Pageable pageable);
* Query Method // tự đọc trong slide để hiểu nhé, rất dễ đọc.

* Còn 3 Slide nữa, đa số đã làm trong project, nên có thể tự đọc và nhớ lại.

----------------------------------------------- RESTful Web Services -------------------------------------------

* The spring-boot-starter-web has built in jackson-databind, which helps to convert JSON into Java object and vice versa.
* @RestController:
	The @RestController annotation was introduced in Spring 4.0 to simplify the creation of RESTful web services.
	It's a convenience annotation that combines @Controller and @ResponseBody – which eliminates the need to annotate
	every request handling method of the controller class with the @ResponseBody annotation
	* @ResponseBody sẽ bind dữ liệu trả ra là ResponseEntity thành json của mỗi method.
* @Path: used to specify the relative path of class and methods. We can get the URI of a webservice by scanning the Path annotation value.
* @GET, @PUT, @POST, @DELETE and @HEAD: used to specify the HTTP request type for a method.
* @Produces, @Consumes: used to specify the request and response types.
@PathParam: used to bind the method parameter to path value by parsing it

* Annotation @RequestBody ánh xạ phần nội dung HttpRequest tới một transfer/domain object,
 cho phép tự động deserialization trên phần nội dung HttpRequest vào đối tượng Java.
 Spring tự động giải mã JSON thành một kiểu Java, giả sử một kiểu thích hợp được chỉ định.

* The @ResponseBody annotation tells a controller that the object returned is automatically serialized into JSON and
 passed back into the HttpResponse object

* Remember, we don't need to annotate the @RestController-annotated controllers with the @ResponseBody annotation
 since Spring does it by default.
* nếu không muốn spring tự động trả về kiểu json, thì ta có thể cài đặt lại trong @RequestMapping attribute 'produces'
	produces = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE }
	produces = { "application/json" , "application/xml" }

* ResponseEntity represents the whole HTTP response: status code, headers, and body.
	As a result, we can use it to fully configure the HTTP response.
	new ResponseEntity<>("Custom header set", headers, HttpStatus.OK); // tham số đầu là dữ liệu, rồi header, httpstatus,
																		không cần header cũng đc.
	
	* ResponseEntity provides two nested builder interfaces: HeadersBuilder and its subinterface, BodyBuilder. 
		Therefore, we can access their capabilities through the static methods of ResponseEntity.
		ResponseEntity.ok("Hello World!"); // đây là phương thức static, của lớp ResponseEntity, build nhanh hơn.
		// còn có các phương thức khác như:
			BodyBuilder accepted();
			BodyBuilder badRequest();
			BodyBuilder created(java.net.URI location);
			HeadersBuilder<?> noContent();
			HeadersBuilder<?> notFound();
			BodyBuilder ok();
			
			// kiểu bodybuilder trong đó có body() trả về một ResponseEntity, contentType() trả về BodyBuilder, contentLength()
			// nói chung không cần tìm hiểu quá sâu.
		
		return ResponseEntity.ok().body("Year of birth cannot be in the future"); // ví dụ như này.
		ResponseEntity.status(HttpStatus.OK).body("Your age is " + calculateAge(yearOfBirth)); // status cũng là static.
		

---------------------------- SPRING SECURITY & SPRING BOOT WEB APPLICATION -----------------------------------
* spring securiry là giải pháp bảo mật toàn diện cho java ee, và hỗ trợ các dự án xây dựng bằng spring framework.
* spring securiry là một module chính khác của spring distribution, và support cho app sử dụng jdk 1.5 trở lên.
* spring security chú trọng vào authentication và authorization.
* spring security được thành nhiều file jar, nhưng spring-security-core.jar là bắt buộc.

* Các đối tượng chính khi làm việc với spring security.
	* Principal: không phải là đối tượng, tượng trưng cho một login user, thông tin user gọi là credential.
		Authentication Object có phương thức getPrincipal để  lấy credentail.
		
	* GrantedAuthority: là interface, triên khai là SimpleGrantedAuthority, chứa tên role của principal.
	
	* SecurityContext: là nơi chưa Authentication sau khi confirm true.
	
	* SecurityContextHolder: là đối tượng cung cấp truy cập đến SecurityContext.
	
	* AuthenticationManager: là đối tượng chỉ định tiến trình authenticate.
	* AuthenticationProvider: là đối tượng cần thiết để tạo ra AuthenticationManager, hai thứ cần cung cấp cho đối tượng
		này là PasswordEncoder và UserDetailsService.
		* đối tượng này chịu trách nhiệm gọi đến UserDetailsService để lấy UserDetails, và so dùng PasswordEncoder để
		so sánh password hai bên nhập.
		
	* UsernamePasswordAuthenticationToken: là đối tượng chứa principal để cho AuthenticationManager authenticate.
		cụ thể là chứa username và password. còn principal ở trên không phải là đối tượng, chỉ là một tên tượng trưng.
		
	* Authentication Object: là đối tượng chứa Principal, và là đối tượng được sinh ra nếu principal được confirm true.
		chứa login credential trong principal.
		* tùy vào cách mình implement hay tự cho spring implememt interface Authentication, nếu trong luồng login thì
			sẽ tự để cho spring tự triển khai, khi đó getPrincipal() sẽ trả về UserDetail.
		* nếu muốn triển khai lại thì getPrincipal() có thể trả lại username hoặc gì đó.
		* trong project thực tế, mình triển khai lại Authentication tại luồng authen jwt, vì luồng này không sử dụng
			AuthenticationManager nên spring không tự sinh ra đối tượng Authentication, nên phải triển khai lại mới]
			có cái dùng và set vào context, để spring dựa vào context lấy role mà access vào api.
			
	* UserDetailsl: là đối tượng được tạo ra nhờ lấy data của user và gắn vào, và đưa mang đi xác thực.
	
	* UserDetailsService: là đối tượng trịu trách nhiệm load data và tạo ra UserDetails bằng hàm loadByUsername() và mang đi
		xác thực.
	
	// Chi tiết xem luồng đi của spring security, tìm file JWT_SECURITY để đọc.
	// xem code trong project.
	
* Bàn luận về JDBC template.
	* đối với spring data jpa, truy xuất dữ liệu chỉ trả về một object hoặc một list các object.
	* đối với Session và Entity Manager, dữ liệu trả về có thể là object, list các object, hoặc một single value.
	* nhưng khi muốn truy vẫn phức tạp hơn, ví dụ khi thông tin của mình cần join rất nhiều bảng, và chỉ lấy vài cột cần
	thiết, sdj, session, entitymanager thì không làm được việc này, nên jdbc template sẽ giải quyết được nhờ đối tượng 
	rowmapper, đối tượng này sẽ lấy kết quả từ resultset và mapping vào một map.
	
	
* Hibernate yêu cầu một constructor không tham số (default constructor) cho một số lý do kỹ thuật và thiết kế.
	Dưới đây là một số lý do tại sao Hibernate yêu cầu default constructor:

	* Quy tắc JavaBeans: Hibernate tuân theo quy tắc của JavaBeans, và một trong những quy tắc cơ bản của JavaBeans là phải
	có một constructor không tham số. JavaBeans là một mô hình lập trình cho các đối tượng Java, và nó định rõ một số yêu cầu
	về cách các đối tượng được tạo và quản lý.

	* Tạo đối tượng: Hibernate cần khởi tạo đối tượng của các lớp được ánh xạ từ cơ sở dữ liệu. Để làm điều này, nó sử dụng
	constructor không tham số để tạo một phiên bản của đối tượng. Nếu không có constructor này, Hibernate sẽ không thể tạo
	đối tượng và thực hiện ánh xạ dữ liệu từ cơ sở dữ liệu vào đối tượng.

	* Đối tượng trạng thái: Hibernate thường tạo mới đối tượng để thực hiện các thao tác CRUD (Create, Read, Update, Delete)
	trên cơ sở dữ liệu. Constructor không tham số cho phép Hibernate tạo đối tượng trong trạng thái ban đầu, sau đó thay đổi
	trạng thái của đối tượng để phản ánh dữ liệu từ cơ sở dữ liệu hoặc thay đổi trạng thái để lưu dữ liệu mới vào cơ sở dữ
	liệu.

	* Thiết kế đối tượng: Một constructor không tham số cho phép bạn đảm bảo rằng đối tượng được tạo với trạng thái ban đầu 
	hợp lệ. Điều này đặc biệt hữu ích khi bạn cần thực hiện kiểm tra và khởi tạo trạng thái ban đầu của đối tượng trước khi
	sử dụng nó.

	* Tóm lại, constructor không tham số là một yêu cầu của Hibernate để đảm bảo quá trình ánh xạ dữ liệu giữa cơ sở dữ liệu
	và đối tượng Java diễn ra một cách đúng đắn và hiệu quả.

* Một ví dụ về conflict trong hibernate 
	; // transient object
	Role role = roleRepository.findById(1); // detached object
	user.setRole(role);
	userRepository.save(user); // transfer transient to persistence.
	// error: detached entity passed to persist, InvalidDataAccessApiUsageException, detached entity passed to persist
	* giải thích:
		* ở đây, role đang ở trạng thái detached, hibernate sẽ không thể lưu một instance ở trạng thái detached, ở đây là ta đang
		lưu role, mà hibernate chỉ làm việc với các đối tượng được truyền vào persistence một cách hợp lệ.
		* để giải quyết lỗi bên trên, ta phải đưa role trở lại trạng thái persistence như merge(), refresh(), update().
	* giải pháp (chưa đúng, sẽ update sau)
		User user =userRepository.save(new User('thien', 20));
		* đưa user vào trạng thái persistence trước khi gán role, điều này làm role được đưa về trạng thai persistence,
		đúng flow của hibernate state. và hibernate sẽ làm viêc đúng.
	* giải pháp khác là đưa role vào persistence bằng các hàm của hibernate.
		* giải pháp này phải dùng hibernate thuần, mở session và thực hiện mọi thao tác trong một session,
		không dùng được không spring data jpa
		* chưa biết spring data jpa hỗ trợ đưa object trở lại persistence kiểu gì.
			* update: gọi entitymanager hiện tại và đưa vào persistence context thông qua hàm update(), merge(), refresh()...

* nói một chút về flow và cycle của các object khi làm việc với hibernate.
	* transient -> persistence -> detached.
	* từ transient không thể sang detached trực tiếp và phải qua persistence.
	* từ persistence sang detached khi session đóng hoặc đưa các persistence object ra khỏi session.
	* từ persistence không thể về transient.
	* từ detached có thể về persistence bằng các hàm hỗ trợ nhưng không thể về transient.
	* các transient object khi không còn được sử dụng thì java sé có cơ chế java garbage để giải phóng các object này 
		để tiết kiệm bộ nhớ.

* bàn về transactional trong spring data jpa.
	* đối với các hàm mặc định của datajpa, tất cả các hàm đã được bọc trong @Transactional.
	* khi cần làm việc với database mà không thông qua các hàm của jpa và bằng native query, bắt buộc phải mở transactional,
		vì spring data jpa sẽ không gọi hibernate để quản lý transaction đối với các loại làm việc với database này.
	* hãy bọc transactional ở tầng service đối với các lời gọi mà spring không hỗ trợ.

* Trong cơ chế IOC, việc java tự tạo các javaBeans bằng cách gọi đến default constructor của bean đó, vì thế, khi triển
	khai bất kỳ bean vào, phải có default constructor.
	

* Khi tạo dự án với spring security, thì spring sẽ tự dùng phương thức basic authentication để bảo vệ api
	và spring sẽ sử dụng tên đăng nhập là 'user' và password tự gen, có thể thấy ở trong log của spring.
	* khi dùng postmant đẻ gọi, bạn phải chọn basic authen để nhập user và password, thông tin này sẽ được mã hóa
		base64 và gửi đi trong header với tiêu đề là Authorization.
	* khi dùng các trình duyệt, spring sẽ tự động gửi ra một trình duyệt đẻ bạn nhập user và password, và spring sẽ dùng
	form mặc định và AuthenticationEntryPoint để check credential, nếu implement lại springSecurity thì form sẽ mất nhưng
	AuthenticationEntryPoint vẫn hoạt đông, và bắt có user và passowrd, thế nên bạn phải triển khai lại luôn
	AuthenticationEntryPoint để spring security hoạt động đúng với cách chúng ta mong muốn.
	
	* khi làm việc với spring security, bạn sẽ thấy không gửi được request với method post, vì đó là cơ chế bảo vệ api
	của spring security, bạn cần gửi kèm sessionId lần request trước mới có thể request với method post lần này.
	* cơ chế này gọi là CORS, yêu cầu với method POST, DELETE, UPDATE,... các phương thức có liên quan đến database
	thì phải gửi sessionId lần request trước mới có thể chấp nhận được.
	
	* như đã biết có hai loại exception, check và uncheck, trong ControllerAdvice, nếu implement cả hai thì exception nào
	sẽ chạy vào đúng hanlder đó, nếu chỉ triển khai một cái thì controllerAdvice và chạy vào bất kỳ dù là Exception hay là
	RuntimeException.
	* nếu muốn bắt exception cụ thể hơn, chỉ cần truyền vào @ExceptionHandler loại exception cần bắt.
	* lưu ý: ControllerAdvice chỉ bắt các exception xảy ra trên tậng controller, còn tất cả các exception ở tần khác
	nếu xảy ra sẽ gây ra gián đoạn chương trình và lỗi server.
	* lưu ý: đối với lỗi xảy ra ở tầng controller, hãy bắt lỗi và trả về lỗi, không nên tự ý kiểm soát và biến hóa lỗi,
	có thể dẫn đến sai lệch dữ liệu.
	
* lưu ý đối với version của jdk khi sử dụng spring boot, từ springboot3. thì chỉ sử dụng được cho phiên bản jdk 17 trở lên,
có thể dùng oracleJdk hoặc openJdk.
* các class dto là các class thay thế cho bean, đại diện cho dữ liệu được đi ra ngoài, thế nên dữ liệu của Dto không nhất
thiết phải giống các java beans, nó có thể là dữ liệu của các javabeans hợp lại, nó làm cho tránh việc truyền tải cả một
javabeans ra ngoài, đôi khi gây đến nhiều lỗi không mong muốn và lộ dữ liệu.


<<<<< LomBok Anotations >>>>>

* @Getter : Generate Getter Method for all the field;
* @Setter : Generate Setter Method for all the field;
* @NoArgsConstructor  : Generate Constructor without paramter;
* @AllArgsConstructor : Generate Constructor with all the field;
* @RequiredArgsConstructor : Generate Constructor for all the field with final or @NonNull Constraint;
* @ToString : Generate ToString Method for all the field;
* @Data : Equivalent to @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode.

+ Note: Becareful when using @Data or @ToString, it can be make StackOverFlow error, because it call all the releventd things to print;




* The Different between @NotNull and @NotBlank and @NotEmpty.
@NotNull: a constrained CharSequence, Collection, Map, or Array is valid as long as it's not null, but it can be empty.
@NotEmpty: a constrained CharSequence, Collection, Map, or Array is valid as long as it's not null, and its size/length is greater than zero.
@NotBlank: a constrained String is valid as long as it's not null, and the trimmed length is greater than zero.

@NotNull: có thể _dùng được cho hầu như tất cả các kiểu dữ liệu trong Java_, từ chối giá trị null hoặc không có nhưng chấp nhận giá trị rỗng. Note: Thậm chí annotation này có thể dùng được cho các kiểu dữ liệu nguyên thủy (int, long, float, double, char, byte...) mà không báo lỗi (mặc dù các kiểu nguyên thủy không thể null) nhưng mà nó sẽ không có tác dụng gì cả.

@NotEmpty: có thể dùng được cho CharSequence (interface của String, StringBuffer và StringBuilder), Collection, Map, Array. Annotation này từ chối cả giá trị null lẫn giá trị rỗng bằng cách kiểm tra độ dài (length) (String) hoặc kích thước (size) (Collection) xem có lớn hơn 0 hay không.

@NotBlank: có thể dùng được cho String. Annotation này từ chối String có giá trị null và String có độ dài là 0 sau khi đã trim (loại bỏ hết khoảng trắng thừa ở đầu và cuối của String)

*
=> @Size dùng để xác định kích thước (số lượng phần tử hoặc số ký tự) của trường (hoặc mảng, bộ sưu tập).
=> @Length dùng để xác định số ký tự của trường (hoặc chuỗi).
=> @Range dùng để xác định giá trị tối thiểu và tối đa của trường (áp dụng cho các loại dữ liệu có thể so sánh được như số nguyên, số thực).
 ==>>> It All Works The Same;

* Number Constraint
=> @Negative: (Hibernate Validator)for Number and value have to be a negative number (nhỏ hơn 0).
=> @NegativeOrZero: (Hibernate Validator)for Number and value have to be a negative number or equal to zero. (nhỏ hơn hoặc bằng 0)
=> @Positive: (Hibernate Validator) for Numberand value have to be a positive number(lớn hơn 0).
=> @PositiveOrZero: (Hibernate Validator) for Number and value have to be a positive number or equal to zero.(lớn hơn hoặc bằng 0).

*
=> @Digits: (Hibernate Validator) xác định số lượng chữ số tối đa sau dấu phẩy trong một số thập phân.
	* Để sử dụng annotation @Digits, bạn cần cung cấp hai tham số:
		* integer: Số chữ số tối đa trước dấu phẩy.
		* fraction: Số chữ số tối đa sau dấu phẩy.

=> @Future: (Hibernate Validator) for Time, must be future;
=> @FutureOrPresent: (Hibernate Validator) for Time, must be future or present;
=> @PastOrPresent: (Hibernate Validator) for Time, must be past or present;


# DataSource
#spring.datasource.url=jdbc:mysql://localhost:3306/bookstore
#spring.datasource.username=root
#spring.datasource.password=
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Hibernate Properties
#spring.jpa.show-sql=true
#spring.jpa.hibernate.ddl-auto=update
#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

#Turn off spring boot banner
#spring.main.banner-mode=off

#Reduce logging level => set logging to warn
#logging.level.root=warn

#Logging config to display sql statement
#logging.level.org.hibernate.sql=debug
#logging.level.org.hibernate.orm.jdbc.bind=trace
#logging.level.org.springframework.security=debug

			
* Các bước để build một dự án spring boot.
	* chuẩn bị Oracle JDK hoặc OpenJDK.
	* sử dụng các ide hỗ trợ tạo spring boot hoặc sử dụng spring initialize.
	* phân chia câu trúc thư mục dự án.
	* liệt kê, tải các thư viện cần thiết.
		* các thư viện của spring boot: springboot-starter, springboot data jpa, springboot security, springboot test,
			springboot validation.
		* các thư viện liên quan: database-connector, Log4j, Mapstruct, Swagger, spring boot devtools, lombok, jwt
			oauth2(nếu triển khai).
		* trong springboot data jpa có hibernate core, jdbc template ...
		* trong springboot validation có hibernate validator.
		* // còn nhiều tự vào thư viện tìm hiểu.
	* code entity
	* config file properties.
	* chạy generate table trong database.
	* config spring security.
		* config CORS // accept all request from different domain or sepecific domain.
		* // update.
	* code and config jwt.
	* triển khai luồng dữ liệu theo mô hình 3 lớp, repository, service, controller.


	
	

	
	
	


	
	

	
	












	




	
	
	
	
	

 


	
		

	

			

		
	*

* 








			


            

           



	
	


		








		



		
	
		
	



	
