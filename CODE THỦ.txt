* Code thủ * 

* JVM, JRE, JDK?
	* Mã java sẽ được biên dịch thành bytecode thay vì mã máy như các ngôn ngữ khác.
	* JVM (java virtual machine) chịu trách nhiệm chuyển đổi bytecode thành mã máy tại thời điểm chạy, giúp ứng dụng java
	của bạn có thể chạy trên mọi hệ điều hành, điều này tạo nên tính độc lập của nền tảng java.
	* JVM chưa đủ để chạy ứng dụng java, cần phải có những thư viện nữa
	* JRE (java runtime environemt) chứa JVM và tất cả các thư viện cần thiết để chạy ứng dụng java.
	* JDK (java development kit) chứa JRE, và bổ sung thêm các bộ công cụ để phát triển ứng dụng java, bao gồm trình biên dịch
	để chuyển mã nguồn thành bytecode, các thư viện để phát triển giao diện người dùng, debugger.
	* nếu chỉ muốn chạy một chương trình java, JRE là đủ, nhưng nếu muốn phát triển và triển khai ứng dụng java, bạn cần JDK
	* JDB (java debugger ), trình debugger trong bộ jdk.
	
	* JVM, JRE và JDK là ba khái niệm quan trọng trong ngôn ngữ lập trình Java mà bất kỳ lập trình viên nào cũng cần biết.
	JVM (Java Virtual Machine) là một máy ảo, chịu trách nhiệm chuyển đổi bytecode (được biên dịch từ mã nguồn Java) thành
	mã máy của hệ thống cụ thể, giúp ứng dụng Java có thể chạy trên nhiều nền tảng khác nhau mà không cần chỉnh sửa.
	JRE (Java Runtime Environment) cung cấp môi trường cần thiết để thực thi ứng dụng Java, bao gồm JVM và các thư viện đi kèm.
	Còn JDK (Java Development Kit) không chỉ chứa JRE mà còn bổ sung các công cụ phát triển như trình biên dịch,
	giúp lập trình viên có thể viết và biên dịch ứng dụng Java một cách hiệu quả.

* Abstract class và Interface?
	* abstract class là một lớp trừu tượng không hoàn toàn, nó chứa các phương thức trừu tượng và cụ thể, và không thể
	khởi tạo trực tiếp, phải khởi tạo thông qua một lớp con extend abstract class.
	* interface là một lớp trừu tượng hoàn toàn, chỉ chứa field và phương thức trừu tượng, cũng không thể khởi tạo, phải
	thông qua một class implement interface class.
	* một class có thể implement nhiều interface nhưng chỉ extend một abstract class.

* Functional interface ? là interface chỉ có duy nhất một phương thức trừu tượng.
* Lambda Expression được giới thiệu trong java8, đơn giản hóa cách triển khai của functional interface. thay vì khai báo lớp
để triển khai functional interface, thì chỉ cần khai báo cách triển khai phương thức của functional interface và sử dụng nó
không thông qua lớp nào hết.

* Generics là một tính năng trong java cho phép bạn định nghĩa một class or interface theo cách mà có thể hoạt động theo
nhiều kiểu dữ liệu khác nhau mà vẫn đảm bảo an toàn cho kiểu dữ liệu (type safety), giúp tái sử dụng code.

* Shadow: là một trường hợp trong java miêu tả việc khi tham số truyền vào phương thức có cùng tên với thuộc tính của lớp,
khi muốn sử dụng thuộc tính của lớp trong phương thức, java không biết là bạn muốn sử dụng thuộc tính hay tham số của phương
thức, theo mặc định, java sẽ ưu tiên tham số (biến cục bộ) hơn, và điều này làm cho thuộc tính bị shadow. Và đây là mục đích
chính của từ khóa 'this' trong java, 'this.<tên thuộc tính>' sẽ làm cho thuộc tính không còn bị shadow, java biết là bạn muốn
sử dụng thuộc tính của lớp. Một lưu ý nhỏ, khi bạn khởi tạo một đối tượng có sử dụng 'this', this ở đây là tham chiếu tới đối
tượng hiện tại, nghĩa là this không thuộc về lớp, mà thuộc về đối tượng, nên this không thể dử dụng trong phương thức static,
bới vì phương thức static thuộc về lớp, và this sẽ không biết tham chiếu tới đối tượng nào. done.

* Super: là từ khóa để gọi đến contructor, properties và method của lớp cha. khi bạn khởi tạo một object, mà object này extend
từ một lớp cha, thì java sẽ khởi tạo object cha trước khi khởi tạo object con, nghĩa là java sẽ phải gọi đến contructor của
lớp cha, nhưng gọi ở đâu?, java sẽ gọi constructor của lớp cha trong constructor của lớp con. theo mặc định java sẽ gọi 
defaul constructor, java sẽ đặt lệnh sau ngay đầu tiên của constructor lớp con 'super();', đây là lệnh java gọi default constructor
của lớp cha. nếu bạn muốn gọi một constructor chứa tham số của lớp cha, bạn có thể truyền tham số vào super().
Ví dụ 'super(name, age);' nhớ là phải luôn đặt ở đầu constructor con, nếu không java sẽ báo lỗi. ghi nhớ là bạn chỉ có thể gọi
constructor cha trong constructor con, bạn không thể gọi bên ngoài constructor con được.
Bạn cũng có thể gọi các properties và method của lớp cha thông qua super, ví dụ 'super.printer()'.
	* Lưu ý: khi bạn kế thừa đa cấp, c extend b, b extend a, khi bạn gọi super trong c thì sẽ gọi đến lớp cha kế thừa
		gần nhất, và ở đây là gọi đến lớp b.

* Nói thêm về interface, mọi properties trong interface đều là public, static, final. mọi method trong interface đều là public
abstract. nhưng trong java8, một method mới được bổ sung vào interface là default method, defaul method là method đã triển khai.
điều này làm cho interface linh hoạt hơn nhiều, giống abstract class nhỉ.

* Bàn luận về hàm main trong java: hàm main là hàm được chạy đầu tiên khi chương trình khởi chạy.
	* public static void main(String[] args){}
	* Hàm main trong nhất thiết nằm trong Main class, nhưng nó phải là duy nhất trong chương trình.
	* public: nó có thể được truy cập mọi nơi trong chương trình.
	* static: nó có thể được chương trình gọi đầu tiên mà không cần khởi tạo lớp.
	* void: nó không trả về gì cả.
	* String[] args: là command line argument, đây là một mảng string được truyền vào khi khởi chạy, ví dụ khi bạn muốn đọc
	một tên file khi khởi chạy, bạn cần truyền vào là lấy ra tại args[0].

* Bàn luận về cách chạy chương trình java
	* javac <name>.java : lệnh javac sẽ sử dụng trình biên dịch trong jdk để biên dịch mã nguồn sang bytecode, bạn sẽ thấy
	một <name>.class được tạo ra trong cùng thư mục.
	* java <name> : jvm sẽ chuyển <name>.class thành mã máy phù hợp với hệ điều hành để chạy chương trình.
	* ví dụ, bạn muốn truyền file test.txt vào command line argument, và bạn có class Main chứa hàm main. làm như sau
		* javac Main.java -> tạo ra Main.class
		* java Main test.txt -> truyền test.txt vào String[] args, tại vị trí 0, và chạy chương trình.
	
* Bàn về Method overloading: làm sao java biết là mình gọi đến method nào khi nhiều method overloading tên giống nhau.
	* Java sẽ dưạ vào method signature bào gồm : Tên + Kiểu & số lượng tham số.
	* Mỗi method có signature khác nhau thì overloading hợp lệ.
	
* Bàn về inner class: inner class là lớp được được khai báo trong lớp, hay còn gọi là lớp trong.
	* lớp bên trong có thể truy cập các thuốc tính và phương thức của lớp bên ngoài dù là private.
	* muốn khởi tạo lớp trong bạn có hai cách:
		* cách 1 là khởi tạo lớp bên ngoài và khởi tạo lớp bên trong.
		* cách hai là bạn đánh dấu lớp bên trong là static, bạn có thể khởi tạo lớp bên trong mà trong cần khởi tạo lớp
		bên ngoài, nhưng điều này làm hạn chế việc truy cập thuộc tính và phương thức của lớp bên ngoài, vì là static nên
		lớp bên trong chỉ có thể truy cập được thuốc tính và phương thức static của lớp bên ngoài, vì các thuộc tính và 
		phương thức của lớp bên ngoài không phải static sẽ không đc khởi tạo khi chưa khởi tạo lớp bên ngoài.
		
* Bàn về anoymous class (lớp vô danh): là lớp con được tạo ra kế thừa lớp cha ngay trong câu lệnh mà ko cần thiết kế lớp con.
	* dùng để triển khai interface hoặc abstract class không thông qua lớp con.
	* nhưng lớp vô danh không thể triển khai nhiều interface như lớp con và kế thừa luôn abstract class như lớp con.
	* lớp vô danh không có tên.
	* chỉ sử dụng được trong block code khai báo lớp vô danh đó. muốn sử dụng ở block code khác phải khai báo lại.

* Bàn về overiding:
	* không thể ghi đè phương thức final hoặc static, vì nó thuộc về lớp và không thay đổi được.
	* access modifier của phương thức ghi đè không được hẹp hơn phương bị ghi đè
	* tên, kiểu trả về , access modifier và kiểu tham số của phương ghi đè phải giống hệt phương thức bị ghi đè.
	* hai class phải có một quan hệ cha con mới ghi đè được cho nhau.
	
* Bàn luận về array:
	* mảng dùng để lưu trữ nhiều giá trị có cùng kiểu dữ liệu, có độ dài cố định và bắt đầu từ 0;
	* ví dụ int[] a = new int[5]; hoặc int[] a = {1,2,3,4,5}
	* với int, khi không gắn giá trị cho các ô nhớ trong mảng, thì mặc định java set là 0, với object là null.
	* mảng cũng là một reference type, lưu trữ địa chỉ bắt đầu của dãy ô nhớ. và dãy ô nhớ đc lưu bên heap.

* Bàn về enum (enumeration): là một kiểu dữ liệu đặc biệt cho phép mình tạo ra một tập hợp các giá trị được định sẵn và không
	thay đổi.
	* Điều thú vị về enum.
	* Bạn có thể tạo constructor cho enum như các class khác, nhưng khi tạo một field mới và set field này vào constructor
	bạn sẽ thấy java báo lỗi ở các Giá trị trong enum, đó là bởi bị mỗi giá trị của enum chính là một instance của enum,
	tức là bạn sẽ phải truyền tham số vào từng giá trị như gọi một constructor vậy.
	* lưu ý, thuộc tính trong enum phải được khai báo final, vì mục đích của enum là giữ cho giá trị không thay đổi.

* Bàn về wrapper class: là một lớp bao giúp chúng ta sử dụng kiểu dữ liệu nguyên thủy như là kiểu dữ liệu tham chiếu.
	điểm đặc biệt của reference data type là nó cung cấp các phương thức để thao tác với primitive data type.
	* int -> Interger; float -> Float; char -> Charater; ...
	* một lưu ý nhỏ, String là một reference data type nhưng nó lại không phải là một wrapper class, bởi vì nó bao lấy 
	một mảng char, chứ không phải là một giá trị nguyên thủy duy nhất.
	* Bạn có thể khởi tạo giá trị cho wrapper class thông qua constructor của nó
	ví dụ: Interger x = new Interger(5); nhưng cách này đã bị java delegate, không khuyến nghị dùng.
	* Bạn có thể khởi tạo qua phương thức valueOf(value) của wrapper class -> gọi là boxing.
	* Bạn có thể khởi tạo trực tiếp cho wrapper class như sau: Interger x = 8; -> gọi là autoboxing.
	* Nhưng autoboxing không hoàn toàn thay thế cho boxing, ví dụ Boolean = true -> đúng; Boolean = 'true' -> sai;
		Boolean = Boolean.valueOf('true') -> đúng; đây là thế mạnh của boxing.
	* Và tất nhiên cũng có unboxing và auto unboxing;
		* int x = Diem.intVlaue(); -> unboxing;
		* int x = Diem -> auto unboxing;
	
	* Một điều phải biết nếu muốn trở thành pro developer
		* Cơ chế Interger Cahing.
		* Khi khởi tạo Interger in1 mà có giá trị từ -128 đến 127, java sẽ lưu object đó vào bộ nhớ cache.
		* Khi bạn khởi tạo một Interger in2 nưã có cùng giá trị, thì nó java cũng điều Interger tham chiếu đến object đã lưu
		trữ trước đó. nên khi so sánh in1 == in2, nó không so sánh giá trị mà là so sánh địa chỉ ô nhớ tham chiếu tới.
		* nên khi khai báo Interger nằm ngoài khoảng -128 đến 127, với cùng giá trị nhưng java sẽ tạo hai object khác nhau để lưu
		giá trị cho hai Interger, vì thế khi so sánh hai Interger với ==, thì sẽ false bởi vì đây là so sánh hai địa chỉ khác nhau.
		* để giải quyết vấn đề này, bạn phải dùng phương thức equal() của wrapper class, nó sẽ tự động unboxing để lấy giá trị nguyên
		thủy để so sánh, nên khi so sánh hai wrapper class, bạn phải sử dụng equal();
		* Các kiểu Float, Double cũng có cơ chế caching. 
		
	* Khi nào dùng wrapper class;
		* Khi dùng java collection; bởi vì các collection chỉ chấp nhận reference data type.
		* Khi bạn muốn lưu giá trị null cho biến mà primitive data type không thể lưu giá trị null;
		* Khi bạn muốn sử dụng các phương thức của object ví dụ như equal(), compareTo(), toString() ...; mà các primitive không có.
		
		* ngoài những lý do trên, bạn ko nên dùng wrapper class vì nó có thể làm chậm chương trình của bạn như quá trình
		boxing và unboxing sẽ tốn time cpu.
		
* Bàn về String: String trong java không phài primitive data type, mà là reference data type, và String là inmutable.
	Tức là không thay đổi.
	* Dành cho ai chưa biết biến nguyên thủy sẽ lưu trữ trực tiếp giá trị dưới dạng nhị phân và được lưu trong stack.
	Còn biến tham chiếu là biến lưu địa chỉ của ô nhớ mà lưu trữ đối tượng.
	* Ví dụ, khi khai báo String x = 'thien', biến x sẽ được lưu trong stack và lưu địa chỉ đối tượng String,
	và đối tượng String với value là 'thien' sẽ được lưu trong bộ nhớ heap, và nằm trong string pool.
	Khi bạn khai báo một biến mơi String y = 'thien', java sẽ vào spring pool xem có đối tượng String nào có giá như vậy không,
	nếu có, y sẽ lưu địa chỉ đối tượng có sẵn trong string pool chứ không khởi tạo một đối tượng String mới.
	* Đó, inmutable giúp tiết kiệm bộ nhớ là như v đó.
	* tại sao lại lưu đối tượng String trong string pool, string pool là một khoảng bộ nhớ trong heap đc java dành ra để
	lưu các đối tượng string, và các đối tượng string trong string pool không được có giá trị trung lặp nhau, điều này giúp
	java tìm kiếm đối tượng string dễ dàng và làm cho String là inmutable, nếu String không inmutable thì cũng không có string pool.
	* lưu ý, khi bạn tạo String z = new String('thien') thì java sẽ khởi tạo một đối tượng hoàn toàn mới nằm ngoài string pool.

* Bàn về checkException và uncheck Exception.
	* checkException là các exception được check tại compile time, các ide sẽ hỗ trợ việc này. và các checkException extend
	từ Exception. (IOException, SQLExeption)
	* uncheck Exception là các exception extend từ runtimeException, nghĩa là không bị check tại thời điểm biên dịch, mà
	có thể gây lỗi tại runtime. (NullPointerExeption, IndexOutOfBoundException).

* Bàn về throw và throws
	* throw để tạo ra một ngoại lệ cụ thể và ném ra khỏi phương thức hiện tại.
		* bình thường dùng try-catch để ném ngoại lệ, nhưng bạn có thể tự tạo ngoại lệ để ném ra.
		* các bược tạo một ngoại lệ cụ thể:
			* Đảm bảo không để java ném ngoại lệ mặc định.
			* Thiết kế một exception extend runtimeException.
			* Ném nó bằng code.
	* throws để nói rằng phương thức này có thể gây ra một hoặc nhiều ngoại lệ. dùng khi khai báo phương thức.
		* nếu phương thức có throws <exception> thì khi gọi đến phương thức này phải xử lý những exception mà phương thức
		này có thể ném ra, dùng try-catch hoặc có thể throws ra tiếp cho tầng khác xử lý. (ducking exception).
		* một lưu ý quan trọng, throws thường được dùng với checkException, vì khi throws checkException ide mới bắt bạn phải
		xử lý luôn exception này, khi throws uncheck Exception, ide không bắt bạn phải xử lý luôn mà chỉ thông báo cho bạn biết
		là có thể có exception.

* Bàn luận về hashCode() và equal().
	* hashCode() thường được sử dụng trong cấu trúc dữ liệu có sử dụng mã hash.
	* ví dụ với Hashet:
		* khi lưu một đối tượng tự thiết kế vào Set, trong Set các object sẽ không được lưu tuần tự, mà dựa vào mã hash được
		sinh ra từ hashCode() mặc định, rồi mỗi mã hash sẽ đánh dấu cho một ô trong bucket.
		* note: các cấu trúc có sử dụng hash lưu đối tượng trong một bucket, một khoảng nhớ trong heap.
		* phương thức equal() có nhiệm vụ so sánh các giá trị của đối tượng với nhau.
		* đối với các class mà java tự viết ra, ta không cần override lại hashCode() và equal(), nhưng đối với các class mà
		ta tự thiết kế, ta phải override lại hashcode() và equal để chạy đúng với ý định của ta.

* Bàn về primitive type và reference type.
	* khi khởi chạy chương trình, mọi biến và function sẽ được load lên ram, và ram chia thành hai phần chính là stack và heap.
	* biến primitive là biến lưu giá trị trực tiếp và lưu ở stack.
	* biến reference là biến lưu địa chỉ của đối tượng, biến thì lưu ở stack, đối tượng thì lưu ở heap.

* Bàn về string pool.
	* String cũng là reference type, nó không lưu giá trị mà là lưu địa chỉ của một mảng byte.
	* string pool là một phần ô nhớ được java dành ra để lưu các String được khai báo cứng.
	* khai báo cứng là autoboxing, ví dụ String name = 'thien'.
	* trong spring pool không thể tồn tại các giá trị trùng lặp, string pool dùng equal() của String để so sánh, tạo string
	mới nếu chưa tồn tại và ngược lại.
	* nếu khai báo với từ khóa new, thì object String này không được khởi tạo trong string pool. nó giống như reference type
	bình thường.

* Bàn về cấu trúc dữ liệu Set.
	* Set dùng một bucket để lưu trữ các object, mỗi ô nhớ trong bucket sẽ tương ứng với một mã hash được tạo ra phụ thuộc
	theo tứng đối tượng.
	* khi thêm phần tử vào set, java sẽ dùng hashcode để lấy mã hash rồi lưu vào ô nhớ tương ứng.
	* hai object có các value giống nhau sẽ sinh ra mã hash giống nhau, lưu ý, chỉ áp dụng với class mà java tạo ra, đối
	với các class mà bạn tự thiết kế, bạn phải override lại hashCode() để tạo ra mã hash giống nhau cho đối tượng giống nhau,
	nếu không, hashcode() mặc định sẽ sinh ra mã hash khác nhau cho đối tượng giống nhau cho class mình tự thiết kế.
	* equal() cũng tương tự như hashcode(), bạn phải override lại nếu muốn nó chạy đúng.
	* khi mã hash giống nhau, java sẽ tìm trong ô nhớ có mã hash đó rồi dùng equal để kiểm tra xem mã có trùng các giá trị
	trong object không, nếu true thì không tạo đối tượng mới, nếu false thì lưu vào ô nhớ có mã hash đó.

* Bàn luận về I++ và ++I;
	* I++: trong  một câu lệnh, prefix i++ sẽ được thực hiện sau tất cả các phép toán trong câu lệnh
		* example:
			int i = 1;
			int a = 0;
			a = 1 + i++; output: 2
			sout(i); output: 2
	* ++I: trong một câu lệnh, postfix ++i sẽ được thực hiện đầu tiên trước tất cả các phép toán trong câu lệnh.
		* example:
			int i=1;
			int a = 0;
			a = i + ++i; output: 3
			sout(i); output: 2
			
* Bàn về hướng đối tượng.
	* Java là một ngôn ngữ hướng đối hoàn toàn.
	* OOP (Oriented Object Programming): làm mô hình lập trình chương trình theo class và object, class là khuôn mẫu để tạo
	ra object, object là thực thể thật được tạo ra từ class.
	* OOP có bốn tính chất sau: polymorphism, Inheritance, Enclapsulation, Abstraction.
	* enclapsulation - tính đóng gói: nghĩa là mọi properties và method đều được đóng gói lại thành một class, và các class
		được đóng lại thành package, đặc trưng làm nên tính đóng gói là access modifier, giúp bảo toàn và bảo mật dữ liệu cho
		đối tượng và chương trình.
	* inheritance - tính kế thừa: mục đích là để tái sử dụng lại các properties và methods của lớp khác mà không cần triển
		khai lại. giúp tiết kiệm code, thời gian và dễ mở rộng chương trình.
	* Polymorphism - tính đa hình: tính đa hình có nghĩa là một đối tượng có thể triển khai một phương thức theo nhiều
		cách khác nhau, overloading sẽ đặc trưng cho điều này. và cái thứ hai là nhiều đối tượng có thể sử dụng chung một
		phương thức nhưng theo những cách khác nhau, đặc trưng cho điều này là inheritance và overiding.
	* abstraction-tính trừu tượng: là class chỉ cung cấp đủ cho người dùng biết các phương thức mà không đi quá chi tiết
		vào cách triển khai của các phương thức này, đặc trưng cho abstraction là interface và abstract class.

* Bàn luận về casting trong java.
	* trong java có hai kiểu dữ liệu, nên cũng có hai kiểu casting, primitive casting và reference casting.
		* Primitive Casting: ép kiểu dữ liệu nguyên thủy.
			* Ép kiểu dữ liệu nguyên thủy có hai loại: Widening và Narrowing.
			* Widening: là ép kiểu dữ liệu nhỏ sang kiểu dữ liệu lớn
				* ví dụ: byte -> int, int -> long, int -> float, float -> double (lưu ý đây là kiểu số, String có khác một chút).
				* với ép kiểu widening, chúng ta không cần khi tường minh kiểu cần ép, java sẽ tự ngầm hiểu, và ép kiểu widening
				sẽ không làm thất thoát dữ liệu, bới vì ép sang dữ liệu lớn luôn luôn đủ bộ nhớ để lưu giá trị của kiểu dữ liệu nhỏ.
			
			* Narrowing: là ép kiểu dữ liệu lớn sang kiểu dữ liệu nhỏ.
				* ví dụ: double -> int, int -> short.
				* với ép kiểu narrowing, chúng ta viết viết tường minh kiểu cần ép sang, và ép kiểu widening có thể sẽ làm thất
				thoát dữ liệu và làm sai lệch dữ liệu, vì kiểu dữ liệu nhỏ sẽ không đủ bộ nhớ lưu giá trị của kiểu dữ liệu lớn.
	
		* Refence Casting: ép kiểu dữ liệu tham chiếu.
		* ép kiểu dữ liệu này ràng buộc bạn phải kiết kiểu dữ liệu tham chiếu là gì, và inheritance, polymophisim trong java.
		nếu bạn hiểu, tôi sẽ trình bày cho bạn hiểu tường tận bản chất của reference casting trong java.
		* ép kiểu reference có hai dạng: Up-Casting và Down-Casting.
			* trước khi trình bày, tôi sẽ định nghĩa lại khái niệm reference casting cho riêng mình:
				reference casting thực chất là chỉ định biến có kiểu dữ liệu này trỏ đến địa chỉ đối tượng thật lưu trong
				heap có kiểu dữ liệu khác nhưng cùng quan hệ. tèn ten.
			* Up-Casting: là ép kiểu từ class con sang class cha. ép kiểu này không cần code tường minh kiểu cần ép, java sẽ
			tự ngầm hiểu.
				* ví dụ:
					Animal a = new Cat();
					a -> là biến lưu trong stack, giá trị của a là địa chỉ đối tượng new Cat();
					new Cat() -> là đối tượng thật lưu trong heap.
					// vì Animal và Cat có quan hệ cha con, nên a hoàn toàn có để trỏ đến đối tượng cat.
					// vì a có kiểu dữ liệu Animal, nên a chỉ biết các method của Animal, vì a trỏ đến đối tượng cat
					// nên method của a gọi đến là method của cat, và a sẽ không thể gọi các method ngoài animal mà cat
					// triển khai thêm. tất nhiên bởi vì biến a là kiểu Animal.
				* Các bạn thấy quen không, khi chúng ta sử dụng java collection, chúng ta đang sử dụng up-casting.
					* ví dụ:
						List<Animal> animals = new ArrayList<>();
						// ở đây List là một interface, nó của là một reference type.
						// ArrayList là lớp triển khai interface List, tức là nó có quan hệ cha con.
						// animal có kiểu List đang trỏ đến địa chỉ của một ArrayList thật trong heap
						// nên khi gọi method của List là gọi đến method của đối tượng ArrayList thật.
						Set<Integer> set = new Hashet<>() // cũng tương tự.
			
			* Down-Casting: là ép kiểu từ class cha sang class con. ép kiểu này cần code tường minh kiểu cần ép.
				* khi các bạn đã hiểu những gì tôi nói ở trên, thì phần down-casting sẽ rất rễ để hiểu.
				* ví dụ
					 Animal a = new Cat();
					 // như ví dụ ở trên, bạn chỉ sử dụng đc các method trong kiểu dữ liệu Animal
					 // vấn đề đặt ra là bạn muốn sử dụng được thêm các phương thức khác của đối tượng thật Cat.
					 // giải pháp là bạn cần ép a thành kiểu dữ liệu Cat.
					 // Animal là lớp cha, Cat là lớp con, ép từ lớp cha sang lớp con thì gọi là down-casting.
					 a = (Cat)a;
					 // tất nhiên để ép được reference type, tất cả các class phải có mối quan hệ inheritance.
					 // đến đây, biến a đã được thay đổi kiểu dữ liệu sang Cat và vẫn trỏ đến đối tượng cat thật trong heap
					 // thế nên a đã có thể gọi đến các method riêng của Cat.
					 a = (Dog)a;
					 // nếu ép kiểu trên thì sao, chắc chắn java sẽ báo lỗi, vì class Dog và class Cat hoàn toàn là
					 // hai kiểu dữ liệu khác nhau, không có mối quan hệ cha con, nên khi biến kiểu Dog mà trỏ đến đối tượng
					 // thật kiểu Cat là hoàn toàn vô lý, động vật có thể là mèo, chứ chó không thể là mèo.
					 Dog b = new Dog();
					 b = (Aniaml)b; // câu này hoàn toàn đúng, Animal và Dog là inheritance.
					 b = (Cat)b; // câu này hoàn toàn sai, Dog và Cat không là inheritance.

* Bàn về String và StringBuilder và StringBuffer.
	* Như đã biết, String là inmutable, nên việc thay đổi chuỗi, nối chuỗi là không thể, nhưng trong chương trình java, việc
	cộng hai chuỗi "Hello" + "World" là công giá trị hai đối tượng vào một đối tượng mới và đưa vào stringpool, đồng thời java
	sẽ lọc và xóa hai đối tượng cũ trong stringpool. Nói ngắn gọn là như vậy nhưng đằng sau việc cộng chuỗi có rất nhiều bước
	thuật toán, điều này làm cho String chậm hơn nhiều StringBuiler và StringBuffer trong thao tác với dữ liệu.
	* StringBuilder và StringBuffer được java thiết kế ra để giải quyết vấn đề hạn chế của String, StringBuilder và StringBuffer
	là mutable, có thể thay đối được.
	* Sự khác nhau giữa StringBuilder và StringBuffer là sự đồng bộ, StringBuilder không được đồng bộ và StringBuffer được đồng
	bộ, nghĩa là trong một chương trình đa luồng, đối tượng StringBuffer sẽ được chia sẻ và được truy cập ở tất cả các luồng,
	còn StringBuffer chỉ được truy cập và chia sẻ trong luồng của nó.
	* StringBuilder có tốc độ nhanh hơn StringBuffer vì ít bước để sử lý dữ liệu hơn StringBuffer.

* Bàn về Thread (Luồng) trong java.
	* Multithread (đa luồng) trong java khi ngoài main thread của chường trình được jvm cung cấp, còn có nhiều luồng khác
	chạy song song với chương trình và có thể sử dụng chung tài nguyên được chia sẻ.
	* Các lỗi thường gặp với đa luồng:
		* Race Condition: là khi một dữ liệu không được đồng bộ hóa, và bị nhiều luồng truy cập và thay đổi đồng thời cùng
		một lúc, dẫn đến việc gia trị của dữ liệu bị thay đối không chính xác, để khắc phục điều này, nên sử dụng cơ chế 
		đồng bộ hóa của java, đặc biệt là trong các giao dịch tài chính.
		* Thread Deadlock: là khi nhiều luồng chờ đợi nhau để giải phóng lock, dẫn đến bị treo vô thời hạn.
		* Starvation: là khi thread này bị chiếm tài nguyên sử dụng bởi thread khác nên luôn ở trạng thái waiting.

* Bàn về ngôn ngữ Java.
	* Java là một ngôn ngữ hướng đối tượng bậc cao, được phát triển bởi Sun, nhưng đã được Oracle mua lại.
	* Java được mệnh danh là ngôn ngữ viết một lần chạy mọi nơi, đặc tính này có là nhờ vào JVM, một máy ảo sử dụng công
	nghệ ảo hóa, chia sẻ chung tiến trình cpu với hệ điều hành chứ không yêu cầu bộ nhớ riêng, jvm có nhiệm vụ chuyển mã
	bytecode sang mã máy phù hợp với OS, chính vì thế java có thể chạy trên mọi OS khác nhau.
	* Java Flatform có 3 phiên bản: Java Micro Edition (Java ME), Java Standard Edition (Java SE), Java Enterprise Edition (Java EE)
		* Java ME: dùng cho các thiết bị nhỏ như mobile..., hoặc hệ thống nhúng, bộ nhớ nhỏ yêu cầu các phiên bản có dung lượng nhỏ.
		* Java SE: hay còn gọi là Java Core, bao gồm tất cả các thư viện cở bản và đầy đủ của java, jvm cũng được viết bằng java core.
		* Java EE: được sử dụng để phát triển phát triển các ứng dụng web, có các thư viện như serverlet, javabeans...
			* Java ee đã được một đội nhóm Oracle phát triển và đổi tên thành jakarta ee, còn java se và me vẫn giữ nguyên.
			* khi tạo dự án spring, ta có thể thấy phiên bản sử dụng trong spring đều là jakarta ee.

* Bàn về apache tomcat:
	* apache tomcat là một phiên bản lightweight của apache, nó là một máy chủ web, hỗ trợ jsp/serverlet.
	* vậy máy chủ web là gì:
		* với nhưng chương trình bình thường, khi run chương trình, chỉ cần jdk là đủ. Nhưng với spring framework, chúng
		ta đang xây dựng một ứng dụng có thể nhận các httprequest và trả httpResponse và chạy được nên phải có một web server
		đứng ra	làm điều này.
		* và trong spring apachetomcat đứng ra làm điều này, apache tomcat cũng hỗ trợ built jsp/servelet động, và nó không
			phải là một reverse proxy.
		
		* Trong framework, khi chạy chương trình ta phải tự import tomcat, và khi chạy ide sẽ bắt chúng ta chọn máy chủ web
		để built.
		* trong spring boot, thì chúng ta đã được tích hợp sẵn máy chủ tomcat để built.

* Bàn về access modifier trong java.
	* Trong java có nhiều loại access modifier: public, private, protected, default, static, abstract ...
	* Bàn về bốn loại chính hay dùng với biến trong class: public, private, protected, default.
	
	* Public: biến hay phương thức public có thể được truy cập qua đối tượng được khởi tạo mọi nơi trong chương trình,
		public được áp dụng khi khai báo class.
		
	* Default: biến hoặc phương thức default được truy cập trong class và từ các đối tượng được khởi tạo trong cùng package,
	nếu đối tượng được khởi tạo không cùng package của class sẽ không truy cập đc các default properties và method. và các
	class con không thể truy cập được biến và phương thức của lớp cha nếu khai báo trong package khác. 
	
	* Protected: biến và phương thức khai báo với protected được truy cập trong class, được truy cập trong class con khai báo
	ngoài hoặc bên package, được truy cập với đối tượng khởi tạo trong cùng package, nhưng không truy cập được đối với đối tượng
	khởi tạo ngoài package.
	
	* Private: các biến và đối tượng private chỉ được truy cập trong lớp, không được truy cập ở bất cứ đâu nữa.
	
	* class chỉ có access modifier là public, abstract;
	
	* properties và methods có các access modifier là public, private, protected, default, static, abstract;
	
	* Constructor có các access modifier là public, private, protected, default;

* Bàn về đa kế thừa trong java.
	* trong java không hỗ trợ đa kế thừa, chỉ hỗ trợ đa triển khai các interface.
	* nhưng java hỗ trợ kế thừa đa cấp, nghĩa là c kế thừa b, b kế thừa a.
	* một số điểm lưu ý sau:
		* trong class con, khi gọi super.method() hay super.properties, nó sẽ gọi đến lớp cha kế thừa gần nhất.
		* muồn họi đến super.super, thì có giải pháp khác là trong class con, tạo một đối tượng class supper.super
		và mỗi lần cần gọi đến method của class super.super, ta chỉ cần gọi đến object super.super đã được khai báo.

* Java Collections
	* List: là một interface nằm trong gói java.util, kế thừ từ Collections interface, và cấp cuối là Itertor interface.
	* List có thể chứa các phần tử có giá trị trùng lặp, tự mở rộng, và được đánh index.
	* List có các triển khai như: ArrayList, LinkedList ...
	* Các method của List hay dùng:
		* void add(E element) - Thêm một phần tử vào cuối danh sách.
		* void add(int index, E element) = Thêm một phần tử vào vị trí chỉ định trong danh sách.
		* boolean addAll(Collection<? extends E> c) - Thêm tất cả các phần tử trong Collection chỉ định vào cuối danh sách.
		* boolean addAll(int index, Collection<? extends E> c) - Thêm tất cả các phần tử trong Collection chỉ định vào vị trí chỉ định trong danh sách.
		* clear() - Xóa tất cả các phần tử trong danh sách.
		* contains(Object o) - Kiểm tra xem danh sách có chứa đối tượng định trước hay không.
		* containsAll(Collection<?> c) - Kiểm tra xem danh sách có chứa tất cả các phần tử trong Collection chỉ định hay không.
		* equals(Object o) - So sánh danh sách với đối tượng chỉ định để xác định liệu chúng có bằng nhau hay không.
		// lưu ý, đối với method equal(), nếu kiểu dữ liệu không phải của java định nghĩa thì phải implement lại hàm equal() để cho chạy đúng.
		* object get(int index) - Trả về phần tử tại vị trí chỉ định trong danh sách.
		* hashCode() - Trả về mã băm của danh sách.
		* indexOf(Object o) - Trả về vị trí đầu tiên của phần tử trong danh sách có giá trị bằng với đối tượng chỉ định.
		* lastIndexOf(Object o) - Trả về vị trí cuối cùng của phần tử trong danh sách có giá trị bằng với đối tượng chỉ định.
		* isEmpty() - Kiểm tra xem danh sách có rỗng hay không.
		* iterator() - Trả về một Iterator để lặp lại các phần tử trong danh sách.
		* object remove(int index) - Xóa phần tử tại vị trí chỉ định trong danh sách.
		* object remove(Object o) - Xóa phần tử đầu tiên trong danh sách có giá trị bằng với đối tượng chỉ định.
		* removeAll(Collection<?> c) - Xóa tất cả các phần tử trong danh sách có trong Collection chỉ định.
		* replaceAll(UnaryOperator<E> operator) - Thay thế tất cả các phần tử trong danh sách bằng kết quả của áp dụng toán tử đơn nguyên chỉ định tới mỗi phần tử.
		// method trên update cách sử dụng sau.
		* retainAll(Collection<?> c) - Xóa tất cả các phần tử trong danh sách không có trong Collection chỉ định.
		* object set(int index, E element) - Thay thế phần tử tại vị trí chỉ định trong danh sách bằng một phần tử mới.
		* size() - Trả về số lượng phần tử trong danh sách.
		* sort(Comparator<? super E> c) - Sắp xếp lại các phần tử trong danh sách bằng cách sử dụng Comparator chỉ định.
		// method trên update cách sử dụng sau.
		* subList(int fromIndex, int toIndex) - Trả về một danh sách con của danh sách, chứa các phần tử từ vị trí fromIndex đến vị trí toIndex – 1.
		* toArray() - Chuyển đổi danh sách thành một mảng.
		* toArray(T[] a) - Chuyển đổi danh sách thành một mảng, với kiểu phần tử chỉ định.
		
	* Set là một interface kế thừa Collection interface. 
	* Set không thể chứa các phần tử có giá trị trùng lặp, tự mở rộng, không được đánh index.
	* Set có các triển khai như: HashSet, LinkHashSet, TreeSet ...
	* Về cơ chế làm việc với dữ liệu, đã viết ở trên, search 'bucket or HashTable'
	* Các method Set cung cấp để làm việc:
		* boolean add(Object element) - Nó được sử dụng để chèn các phần tử vào set.
		* boolean addAll(Collection c) - Nó được sử dụng để chèn tất cả các phần tử của c vào set.
		* void clear() - Xóa tất cả các phần tử khỏi set.
		* boolean contains(Object element) - Trả về true nếu tập hợp này chứa phần tử đã chỉ định.
		* boolean containsAll(Collection c) - Trả về true nếu set chứa tất cả các phần tử của collection c đã chỉ định.
		* boolean equals(Object o) - So sánh các đối tượng được chỉ định với set.
		// cũng lưu ý như trên, phải implement lại equals() đối với dữ liệu java không định nghĩa và Set dùng HashTable, vì thế
		// cũng phải implement lại HashCode() cho kiểu dữ liệu tự định nghĩa này.
		* boolean isEmpty() - Trả về true nếu set không chứa phần tử.
		* int hashCode() - Trả về giá trị mã băm
		* Iterator iterator() - Trả về một trình vòng lặp iterator để duyệt qua các phần tử của set.
		* boolean remove(Object o) - Xóa phần tử đã chỉ định khỏi set.
		* boolean removeAll(Collection c) - Xóa khỏi set tất cả các phần tử của nó được chứa trong collection c đã chỉ định.
		* boolean retainAll(Collection c) - Chỉ giữ lại các phần tử trong set được chứa trong collection c đã chỉ định.
		* int size() - Trả về số lượng các phần tử của set.
		* Object[] toArray() - Trả về một mảng chứa tất cả các phần tử trong set.
		* T[] toArray(T[] a) - Trả về một mảng chứa tất cả các phần tử trong set, kiểu run-time của mảng trả về là kiểu đã chỉ định.
		* Sort // Set không cup cấp method sort, muốn sort thì có thể dùng stream() trong java 8, có các method hữu ích để sort Set.
	
	
	* Map là một interface kế thừa java collection.
	* Map lưu trữ giá trị bằng cặp key-value.
	* Map không thể chưa key giống nhau, nhưng có thể chứa value giống nhau với key khác nhau, tự mở rộng, không đánh index.
	* cơ chế làm việc viết ở trên, search 'bucket' or 'hashtable'
	* Map có các triển khai như HashMap.
	* Map cung câp các method sau:
		* void clear() - Gỡ bỏ tất cả cặp key/value từ Map đang gọi
		* boolean containsKey(Object key) - Trả về true nếu Map đang gọi chứa k như là một key. Nếu không là false
		* boolean containsValue(Object v) - Trả về true nếu Map đang gọi chứa v như là một value. Nếu không là false
		* boolean equals(Object obj) - Trả về true nếu obj là một Map và chứa cùng các Entry. Nếu không là false.
		* Object get(Object key) - Trả về value mà liên kết với key
		* int hashCode() - Trả về hash code cho Map đang gọi
		* Object put(Object key, Object value) - Đặt một entry vào Map đang gọi, ghi đè bất kỳ value trước mà liên kết với key.
			Với key và value tương ứng là k và v. Trả về null nếu key đã không tồn tại. Nếu không thì,
			value trước mà liên kết với key được trả về
		* void putAll(Map map) - Đặt tất cả entry từ m vào trong Map này
		* Object remove(Object key) - Gỡ bỏ entry mà có khóa là key được chỉ định.
		* int size() - Trả về số các cặp key/value trong Map
		* Collection values() - Trả về một tập hợp chứa các value trong Map. Phương thức này cung cấp một collection-view
		của các value trong Map
		* Set keySet() - Nó được sử dụng để trả đối tượng Set có chứa tất cả các keys.
		Set entrySet() - Nó được sử dụng để trả lại đối tượng Set có chứa tất cả các keys và values.
	
	* Stream trong java 8
		* Stream là một đối tượng mới trong java 8, giúp làm việc với Collection và Array đơn giản hơn nhiều.
		* Stream nằm trong gói java.util.stream
		* Collection interface được hỗ trợ hai phương thức để tạo Stream
			* stream(): trả về môt stream được sử lý theo tuần tự.
			* parallelStream(): trả về một stream song song, các xử lý sẽ được thực hiện song song.
		* Trong phần đầu, ta tìm hiểu stream() tuần tự trước.
		
		* Đặc điểm của java Stream:
			* không lưu các phần tử của Collection hay Array, chỉ thực hiện các phếp toán tổng hợp để có đc stream mong muốn.
			* không phải là một cấu trúc dữ liệu
			* dữ liệu để xử lý ở trong một stream, không ảnh hưởng dến dữ liệu nguồn.
			* tất cả hoạt động của stream là Lazy.
			* các phần từ chỉ được truy cập một lần trong vòng đời của stream, giống như iterator, phải tạo mới để duyệt lại.
			* stream không dùng lại được khi đã gọi thao tác cuối.
			* không dùng được index trong stream
			* stream hỗ trợ thao tác song song các phần tử Collection hay Array nhờ ParellelStream().
		
		* nói dễ hiểu hơn, stream là một luồng chứa các dữ liệu nguồn và thực hiện tính toán trên luồng đó,
			nên không thay đổi dữ liệu gốc, và có thể chuyển đổi kiểu dữ liệu thành các dạng khác nhờ hàm collect();
		
		* Cách làm việc với stream: làm việc với string luôn luôn thông qua 3 bước sau.
			* tạo Stream (stream source).
			* thực hiện các thao tác trung gian (intermediate oprations), là thực hiện biến đổi stream ban đầu thành stream khác.
			* thực hiện thao tác cuối (terminal operation), là lệnh cuối để nhận kết quả và sau đó không thể sử dụng lại stream.
				// ví vụ
				myArray.stream().filter(x => x % 2 == 0).count();
				// stream() -> là tạo stream source.
				// filter() -> là intermediate operation
				// count() -> là terminal operation
			* Cấu trúc chung của một stream pipeline gồm:
				* 1 stream source
				* 0 hoặc nhiều intermediate operation
				* 1 terminal operation.
		
		* Các cách tạo stream.
			* Stream interface trong gói java.util.stream chỉ làm việc với kiểu dữ liệu reference.
			* với các kiểu primitive, có thể sử dụng stream dành cho các kiểu đối tượng đó như: IntStream, LongStream, DoubleStream ...
			
		* các intermediate operation quen thuộc:
			* filter()
				* nhận vào một predicate, triển khai bằng lamda hoặc method reference
			* skip(), limit()
				* skip: loại bỏ không lặp qua các phần tử trước nó.
				* limit: giới hạn trong stream mới có bao nhiêu phần tử.
			* map()
				* thực hiện biến đổi các elemnt trong stream và trả vào stream mới.
			* sorted()
				* nhận vào comparator, triển khai bằng lambda hoặc method reference.
			* forEach()
				* lặp qua từng phần tử và làm theo chỉ định.
			* collect()
				* gom các phần tử lại và làm theo chỉ định.
			* anyMatch(), allMatch(), noneMatch()
				* đều nhận vào predicate, triển khai bằng lambda hoặc method reference.
				* anyMatch: trả về true nếu phần tử đầu tiên match predicate, còn không trả về false.
				* allMatch: trả về true nếu all element trong stream match, nếu có element không match trả về false.
				* noneMatch: trả về true nếu không có phần tử nào match, ngược lại false.
			* count()
				* đếm số element trong stream trả về số nguyên kiểu Long.
			* min(), max()
				* đều nhận vào comparator.
				* thực hiện so sánh và lấy giá trị lớn nhất và nhỏ nhất.
			* reduce()
				* update
			* summaryStatistics()
				* trả về một summaryStatistics chứa các giá trị: count(), sum(), avg(), min(), max().
				* Có các kiểu như IntSummaryStatistics, DoubleSummaryStatistics, LongSummaryStatistics.
			* boxed()
				* Được thiết kế cho các stream của primitive type (IntStream, DoubleStream, and LongStream) để đóng gói
				các primitive element trong stream thành các Wrapper Class tương ứng.
		* Luồng song song - parallel Streams
			* như đã nói ở trên, stream có hai dạng là tuần tự (sequential) hoặc song song(parallell)
				nghĩa là các thao tác trên stream tuần tự chỉ được chạy trên một luồng, còn các thao tác trên stream song song
				được thực hiện trên đa luồng.
				// hiểu đơn giản là một stream sẽ có n số thao tác nhất định, thay vì n thao tác chạy trên một core thì n thao tác
				sẽ được jvm chia đều và chạy trên nhiều core tùy theo số core của máy tính.
			* chỉ cần thay stream() thành parallelStream(), nếu máy tính có nhiều core thì tốc độ để thực hiện xong n thao tác càng nhanh.
		
		* // chi tiết xem code tại JavaBackend project.
	
	* Bàn về lamda expression
		* Như đã nói về funtional interface, thì function interface được ra mắt trong java 8, nó giúp thực hiện hóa mô hình lập trình
		hướng chức năng (functional programing), trước java 8, mọi method đều nằm trong đối tượng, tức là hướng đối tượng hoàn toàn, muốn
		sử dụng các method phải khởi tạo object hoặc là dùng tên object. và functional interface giúp thực hiện hóa việc này.
		* trước đây, để dùng một interface mà chưa có class nào triển khai, thì ta có thể trực tiếp khai báo trong class (inner class)
		và được gọi là anonymous class, nhưng nó vẫn là đi triển khai một class, chưa là một chức năng riêng biệt.
		* lamda expression giúp ta triển khai functional interface một cách ngắn gọn, hướng chức năng hoàn toàn, không thuộc về class nào
		và không có bất kỳ access modifier nào. và việc triển khai lamda gọi là một anonymous method.
	
		* Tồng quan:
			* Cung cấp bản implement cho Functional interface.
			* Viết ít code hơn.
			* Hiệu quả hơn nhờ hỗ trợ thực hiện tuần tự (sequential) và song song (parallel) thông qua Stream API.
		* Cú pháp biểu thức lamda: (argument-list) -> {body}
			* argument-list: có thể có hoặc không có, tùy thuộc vào parameter của functional interface muốn triển khai
			* arrow-function (->): dùng để liên kết phần argument-list và body
			* body: chứa các câu lệnh của biểu thức lamda
		* sự khác biệt của biểu thức lamda:
			* không có tên: tức là một anonymous method
			* có thể có hoặc không có câu lệnh return: tức là không tường minh, java có thể tự suy luận đc kiểu trả
			về theo code thực thi.
		* Trước Java 8: chúng ta tạo anonymous inner classes để triển khai chức năng của interface.
		* Từ Java 8: sử dụng biểu thức lambda thay vì các anonymous inner classes.
		
	* Các loại functional interface mà java định nghĩa phổ biến:
		* Comparator: dùng để so sánh hai đối tượng định nghĩa một phương thức duy nhất
			là compare(T o1, T o2) để so sánh hai đối tượng o1 và o2.
			* ví dụ: List<String> names = Arrays.asList("John", "Doe", "Alice", "Bob");
					 Collections.sort(names, (s1, s2) -> s1.compareTo(s2)); // triển khai bằng lamda expression
		* Predicate: được dùng để kiểm tra một điều kiện.
			* Nó có một phương thức là test(T t) trả về true hoặc false dựa trên điều kiện kiểm tra.
			* ví dụ: List<String> names = Arrays.asList("John", "Doe", "Alice", "Bob");
					Predicate<String> startsWithA = s -> s.startsWith("A"); // triển khai bằng lamda expression.
					List<String> result = names.stream().filter(startsWithA).collect(Collectors.toList());
		* xem code trong project java8
		
	* Bàn về Method Reference: được giới thiệu java 8, cũng hỗ trợ cho việc lập trình functional programing.
		* thay thế cho lamda expression, giúp cho lamda expression được rút gọn ngắn lại hơn giúp dễ đọc mà nguồn.
		* ví dụ: 
			// Lambda expression
			List<String> names = Arrays.asList("John", "Doe", "Alice", "Bob");
			names.forEach(s -> System.out.println(s));
			// Method reference
			names.forEach(System.out::println);
			// forEach(String::toString) == s -> String.toString(s)
		* method reference không thể thay thế cho tất cả trường hợp của lamda expression, việc một lamda expression khó không thể triển khai
		bằng method reference.
	
	* Collection và Collections
		* Collection là interface cao thứ 2 trong Collection framework, đứng đầu là Iterable.
		* Collections là một class, cung cấp các static method để thao tác trên các Collection object.
		* Phần này chỉ nói về Collections Class.
		* Đặc điểm:
			* hỗ trợ các thuật toán đa hình hoạt động trên collection.
			* nếu truyền vào một null object, Collections sẽ ném ra lỗi NullPointerException.
		
		* một điểm cần lưu ý
			* đối với stream, nó luôn tác động và các phần tử được copy ở luồng riêng, nhưng đối với các method của Collections
			method nào thay đối element thì sẽ thay đổi trên phần tử gốc, nghĩa là sau các operations, object nguồn đã bị thay đổi.
		* Các thuộc tính của Collections:
			* static List EMPTY_LIST: khởi tạo một list rỗng, inmutable
			* static Map EMPTY_MAP: khởi tạo một map rỗng, imutable
			* static EMPTY_SET: khởi tạo một set rỗng, imurtable
		* Các method phổ biến hay dùng:
			* addAll(Collection, T ...elements): thêm các elements và Collection.
			* binarySearch(List extend Comparable, T key): tìm kiếm và trả về index.
			* void copy(List dest, List src): copy elements này sang list dest.
			* disjoint(collection, collection): Trả về true nếu hai bộ sưu tập được chỉ định không có các phần tử chung.
			* emptyList(): trả về list rỗng và immutable
			* emptySet():
			* emptyMap():
			* file(List t, T obj): thay thế tất cả phần tử trong danh sách được chỉ định với phân tử được chỉ định
			* frequency(Collection c, Object o): trả về số lượng các phần tử có trong collection bằng đối tượng chỉ định
			* có rất nhiều phương thức hay, hãy đọc thêm trong library
	
	* ==>> Khi làm việc với Collection, chọn Collections hoặc stream, search cách sử dụng nếu không biết.
			
		
	* Comparable and Comparator:
		* OverView
			* Comparable dùng cho các method của Collections hay stream cho so sánh mặc đinh, đối với các kiểu tự định nghĩa phải
			implement lại.
			* Comparator dùng cho các trường hợp mà các method của Collections hay stream cần truyền vào một Comparator để dựa vào
			so sánh. Có thể được định nghĩa theo nhiều cách khác nhau và linh hoạt hơn.
	
	* Synchronize và Asynchronize.
		* lập trình bất đồng bộ (code chương trình không chạy đồng bộ, tức là đa luồng, đã tìm hiểu rồi).
		* vấn đề đặt ra là khi nhiều task chạy trên nhiều luồng khác nhau cùng truy cập vào một share resource nào đó,
		các thread này sẽ thay đổi shared resource cùng một lúc, dẫn đến kết quả thực thi sai so với expectation.
		* lập trình đồng bộ có hai dạng:
			* khi chương trình chỉ chạy trên thread main -> nó đã đồng bộ sẵn
			* khi chương trình có nhiều thread -> vấn đề đặt ra làm sao các parallel thread chỉ được lần lượt truy cập vào shared resource
			chứ không phải được truy cập đồng thời cùng một lúc (sử lý đồng bộ trong bất đồng bộ)
			* từ khóa Synchronize sẽ giải quyết vấn đề này: trước mỗi method, object, block, variable hãy thêm từ khóa Synchronize, java sẽ
			khóa các elements trên, chỉ cho phép một thread tác động lên shared resource tại cùng một thời điểm, điều này đảm bảo chương
			trình chạy đúng khi chương trình có nhiều thread.
			* xem code chi tiết trong project
			* phần này chưa thực hành nhiều (sẽ update soon).
			
	* Callable, Future và Excutor
		* Trước đây muốn lập trình bất đồng bộ, ta phải extend thread (gọi start() để chạy)
		hoặc implement runable (override lại run()) để có thể tạo ra các luồng riêng,
		nhưng ta có thể dùng một cách ngắn gọn hơn và quản lý tốt hơn với Callable, Future và Excutor.
		* Callable là một interface trong java, nó định nghĩa một công việc và trả về một kết quả trong tương lai và có thể throw Exception
		* Future là kết quả trả về của Callable, nó thể hiện kết quả của một phép tính không đồng bộ, cho phép kiểm tra trạng thái của phép
		tính (đã thực hiện xong chưa, kết quả trả về là gì…)
		* Executors là một class tiện ích trong Java, dùng để tạo thread pool, đối tượng Callable cho các xử lý bất đồng bộ.
		* khi submit một callable implementation vào excutorservice, ASynchronize task đó sẽ được chạy mà ko cần gọi call() method.
		
	* CompletableFuture
		* là một đối tượng được giới thiệu trong java 8, tiện lợi hơn nhiều so trong việc thực hiện bất đồng bộ so với các cách trên.
		* CompletableFuture là kết quả trả về của phép tính / method không đồng bộ, cho phép kiểm tra trạng thái của phép tính
		(đã thực hiện xong chưa, kết quả trả về là gì…), bắt sự kiện khi method hoàn thành…
		* có thể thực hiện Asynchronize task bằng method supplyAsync(Supplier) hoặc (Supplier, Excutor), và trả về một new CompletableFuture.
		không cần thực hiện implement Callable để thực hiện ASynchronize task, vì CompletableFuture đã implement Callable và CompletionStage.
		* supplier là functional interface, hãy triển khai bằng lamda expression.
		* sẽ update thêm về sử lý đồng bộ trong bất đồng bộ.
		* CompletableFuture chính nó giúp chạy ASynchronize task và cũng chính nó nhận result trả về từ ASynchronize task và nhiều method
		để thực hiện tiếp (sẽ update các method sau).

* OracleJDK và OpenJDK.
	* ban đầu, chỉ có một mã bộ mã nguồn java duy nhất là jdk của sun microsystems, khi java được chuyển giao cho oracle
		thì bộ mã nguồn java được đổi tên thành OracleJDK. được Oracle phát triển như một sản phẩm.
	* Vì là Open Source, nên một cộng đồng đã đóng góp rất nhiều vào bộ mã nguồn java, và sinh ra một phiên bản có tên là
		OpenJDK, OpenJDK cũng được được đội ngũ của oracle support phát triển, nhưng có một số tính năng của oraclejdk mà
		openjdk không có, bản oraclejdk có đầy đủ liences nên có nhiều module được chấp nhận sử dụng trên nhiều môi trường
		khác nhau, openjdk đôi khi không có điều này.
	
	* Một sự kiện lớn xẩy ra vào tháng 10 năm 2009, Oracle mua Sun Microsystem, như vậy Java đã chính thức thay đổi chủ sở hữu.
		Hãy chú ý tới thời điểm trước và sau năm 2009.
		
	* Các phiên bản Java từ 1 đến 6 được phát triển bởi Sun Microsystem, họ mở mã nguồn của Java cho tất cả mọi người trên thế giới.
		Tháng 7 năm 2011, Oracle phát hành Java 7, họ đã phát hành 2 biến thể khác nhau của JDK là Oracle JDK và OpenJDK,
		thời điểm đó mã nguồn của 2 biến thể này không có quá nhiều sự khác biệt, bởi vì chúng đều được thừa kế từ JDK 6.

	* OpenJDK được mở mã nguồn, nó được bảo trì và phát triển bởi Oracle, nhưng cho phép cộng đồng và các công ty khác tham
		 gia vào sự phát triển này, chẳng hạn như Red Hat, Azul Systems, IBM, Apple Inc... OpenJDK vừa là một sản phẩm JDK
		 vừa là một đặc tả (specification), bất kỳ một công ty, tổ chức nào muốn sử dụng OpenJDK để tạo ra một biến thể mới
		 phải tuân thủ các đặc tả đó.
	* OpenJDK được phát triển bởi Oracle và sự đóng góp từ cộng đồng, đôi khi chúng ta gặp vấn đề với sự ổn định, dựa trên
		phản hồi của người dùng nó sẽ được nâng cấp để tốt hơn. OpenJDK được cập nhập thường xuyên, khoảng 6 tháng một lần.

	* Oracle JDK được bảo trì và phát triển bởi Oracle, và tuân thủ các đặc tả của OpenJDK, nhưng nó không được mở mã nguồn.
		Oracle JDK tốt hơn nhiều về khả năng đáp ứng và hiệu năng JVM. Nó tập trung nhiều hơn vào sự ổn định do tầm quan trọng
		của nó đối với khách hàng doanh nghiệp của mình.
